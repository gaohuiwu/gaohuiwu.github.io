<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gcoder</title>
  
  <subtitle>www.gcoder5.com</subtitle>
  <link href="https://gcoder5.com/atom.xml" rel="self"/>
  
  <link href="https://gcoder5.com/"/>
  <updated>2023-03-12T09:09:34.985Z</updated>
  <id>https://gcoder5.com/</id>
  
  <author>
    <name>Gcoder</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>说说这些年用的docker</title>
    <link href="https://gcoder5.com/2023/03/12/%E8%AF%B4%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%B9%B4%E7%94%A8%E7%9A%84docker/"/>
    <id>https://gcoder5.com/2023/03/12/%E8%AF%B4%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%B9%B4%E7%94%A8%E7%9A%84docker/</id>
    <published>2023-03-11T23:38:24.000Z</published>
    <updated>2023-03-12T09:09:34.985Z</updated>
    
    <content type="html"><![CDATA[<p>不得不说，近些年的容器技术得到了大面积的推广和使用，而在这几年中，我也略有使用，所以本文想记录下近些年在使用docker上的一些使用心得和使用经验。</p><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>每个工具的使用第一步都是安装，我们也不例外。</p><p><code>Centos7</code>为例</p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><code>Docker</code> 支持 64 位版本 <code>CentOS 7/8</code>，并且要求内核版本不低于<code> 3.10</code>，如果内核版本不满足的，请升级内核。</p><h4 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h4><p>旧版本的 Docker 称为 <code>docker</code> 或者 <code>docker-engine</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum remove docker \<br>                  docker-client \<br>                  docker-client-latest \<br>                  docker-common \<br>                  docker-latest \<br>                  docker-latest-logrotate \<br>                  docker-logrotate \<br>                  docker-selinux \<br>                  docker-engine-selinux \<br>                  docker-engine<br></code></pre></td></tr></table></figure><h4 id="更换yum国内源"><a href="#更换yum国内源" class="headerlink" title="更换yum国内源"></a>更换yum国内源</h4><ol><li><p>安装依赖包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum install -y yum-utils<br></code></pre></td></tr></table></figure></li><li><p>添加<code>yum</code>软件源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum-config-manager \<br>    --add-repo \<br>    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br><br>sudo sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">官方源</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">sudo yum-config-manager \</span><br><span class="language-bash"><span class="hljs-comment">#     --add-repo \</span></span><br><span class="language-bash"><span class="hljs-comment">#     https://download.docker.com/linux/centos/docker-ce.repo</span></span><br></code></pre></td></tr></table></figure></li><li><p>需要测试版本的Docker请执行以下命令（可选）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum-config-manager --enable docker-ce-test<br></code></pre></td></tr></table></figure></li></ol><h4 id="使用yum安装docker"><a href="#使用yum安装docker" class="headerlink" title="使用yum安装docker"></a>使用yum安装docker</h4><ol><li><p>更新yum</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum update<br></code></pre></td></tr></table></figure></li><li><p>安装docker-ce</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure></li></ol><h4 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl enable docker<br>sudo systemctl start docker<br></code></pre></td></tr></table></figure><h4 id="让普通用户也可以使用docker"><a href="#让普通用户也可以使用docker" class="headerlink" title="让普通用户也可以使用docker"></a>让普通用户也可以使用docker</h4><blockquote><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p></blockquote><ol><li><p>将当前用户加入到docker组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-variable">$USER</span> 当前用户</span><br>sudo usermod -aG docker $USER<br><span class="hljs-meta prompt_"># </span><span class="language-bash">sudo gpasswd -a <span class="hljs-variable">$USER</span>  docker</span><br></code></pre></td></tr></table></figure></li><li><p>重启</p><p>重启后生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">reboot<br></code></pre></td></tr></table></figure></li></ol><h3 id="安装可视化工具portainer"><a href="#安装可视化工具portainer" class="headerlink" title="安装可视化工具portainer"></a>安装可视化工具<code>portainer</code></h3><p>安装好了<code>docker</code>之后，我们可以通过各种命令来愉快的进行操作，同时呢，我们也可以借助可视化工具来对多个docker进行管理，方便我们查看日志，或者管理容器。</p><p>在可视化工具这一块，我经常使用的是<code>portainer</code>，所以接下来就展示下如何安装及使用该工具。</p><h4 id="安装portainer"><a href="#安装portainer" class="headerlink" title="安装portainer"></a>安装<code>portainer</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查找portainer</span><br>docker search portainer<br><span class="hljs-meta prompt_"># </span><span class="language-bash">拉取portainer</span><br>docker pull portainer/portainer<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动容器</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.创建挂载文件</span><br>mkdir -p /home/data/docker/portainer/data<br>chmod 777 -R /home/data/docker/portainer/<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.启动</span><br>docker run -d \<br>-p 19000:9000 \<br>-p 18000:8000 \<br>--restart=always --privileged=true \<br>-v /var/run/docker.sock:/var/run/docker.sock \<br>-v /home/parallels/docker/portainer/data:/data \<br>--name portainer portainer/portainer<br></code></pre></td></tr></table></figure><h4 id="访问portainer"><a href="#访问portainer" class="headerlink" title="访问portainer"></a>访问<code>portainer</code></h4><p>在随便一个浏览器访问</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">http://localhost:19000<br></code></pre></td></tr></table></figure><p><span style="color:blue"><strong>初次访问会需要设置一个用户密码！</strong></span></p><p><img src="https://p.ipic.vip/1f3wyn.png" alt="image-20230312082729288"></p><p>登录之后，我们可以看到如上的一个界面，具体的使用细节我就不再赘述了，相信小伙伴们安装到了这步之后，就知道如何去使用了～</p><h4 id="通过portainer连接多个docker"><a href="#通过portainer连接多个docker" class="headerlink" title="通过portainer连接多个docker"></a>通过<code>portainer</code>连接多个<code>docker</code></h4><p>我们上面说过，这个工具是可以管理多个docker的，所以接下来我们来介绍下如何接入（以下主要是<code>api</code>的连接方式）</p><ol><li><p>前期准备</p><p>首先，我们需要明确一件事情，就是我们要接入的远程docker服务是已经开放<code>2375</code>端口供外部链接（如没有，可根据如下步骤操作）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">我们假设远程docker服务叫做A，那么接下来我们需要对A所在的服务器进行操作</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.修改docker配置文件</span><br>vi /usr/lib/systemd/system/docker.service<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在ExecStart=/usr/bin/dockerd-current添加配置</span><br>-H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.防火墙开放端口（如有开启防火墙的话，需要配置）</span><br>firewall-cmd --zone=public --add-port=2375/tcp --permanent<br>firewall-cmd --reload<br></code></pre></td></tr></table></figure></li><li><p>配置远程docker服务</p><p>添加<code>Environment</code></p><p><img src="https://p.ipic.vip/1psai5.png" alt="image-20230312083859322"></p><p>我这里选择<code>Docker Standalone</code></p><p><img src="https://p.ipic.vip/vbp3rk.png" alt="image-20230312083952874"></p><p>连接方式我们选择<code>api</code>，其他的方式也可以，需要的小伙伴可以自行尝试～</p><p><img src="https://p.ipic.vip/o2u9r8.png" alt="image-20230312084210676"></p><p>到这里，我们就将远程的docker服务添加进来了。</p></li></ol><h3 id="用docker-compose安装redis"><a href="#用docker-compose安装redis" class="headerlink" title="用docker-compose安装redis"></a>用<code>docker-compose</code>安装<code>redis</code></h3><p><code>Compose </code>是用于定义和运行多容器 <code>Docker</code> 应用程序的工具。通过<code> Compose</code>，您可以使用<code> YML</code> 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p><p>Compose 使用的三个步骤：</p><ul><li>使用 <code>Dockerfile</code> 定义应用程序的环境。</li><li>使用 <code>docker-compose.yml </code>定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li><li>最后，执行 <code>docker-compose up </code>命令来启动并运行整个应用程序。</li></ul><p>接下来，我们用安装<code>redis</code>来介绍如何使用<code>docker-compose</code>构建我们需要的doker服务</p><h4 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装<code>docker-compose</code></h4><ol><li><p>下载当前的稳定版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo curl -L &quot;https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure></li><li><p>将可执行权限应用于二进制文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo chmod +x /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure></li><li><p>创建软链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose<br></code></pre></td></tr></table></figure></li><li><p>查看版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose version<br></code></pre></td></tr></table></figure><p><img src="https://p.ipic.vip/53l1n0.png" alt="image-20230312094311903"></p><p>至此安装成功。</p></li></ol><h4 id="新建redis相关的目录"><a href="#新建redis相关的目录" class="headerlink" title="新建redis相关的目录"></a>新建redis相关的目录</h4><p>建立这些目录是为了让我们更好的管理和复用</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">redis<br>|---compose<br>|---docker-compose.yml      ---compose配置文件<br>|---data                          ---redis数据存储目录（挂载用）<br>|---logs                          ---redis日志文件目录（redis.conf中logfile设置相对路径则不需要）<br>|---redis.conf                    ---redis配置文件<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir redis &amp;&amp; cd redis<br>mkdir compose data logs<br>touch compose/docker-compose.yml<br>touch redis.conf<br></code></pre></td></tr></table></figure><h4 id="编辑redis配置文件"><a href="#编辑redis配置文件" class="headerlink" title="编辑redis配置文件"></a>编辑redis配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi redis.conf<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs conf">#开启远程可连接<br>#bind 127.0.0.1<br>#自定义密码<br>requirepass 12345678<br>#指定 Redis 监听端口(默认:6379) <br>port 6379<br>#客户端闲置指定时长后关闭连接(单位:秒。0:关闭该功能) <br>timeout 0<br># 900s内如果至少一次写操作则执行bgsave进行RDB持久化操作<br>save 900 1<br># 在300s内，如果至少有10个key进行了修改，则进行持久化操作<br>save 300 10<br>#在60s内，如果至少有10000个key进行了修改，则进行持久化操作<br>save 60 10000<br>#是否压缩数据存储(默认:yes。Redis采用LZ 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大<br>rdbcompression yes<br>#指定本地数据文件名(默认:dump.rdb)<br>dbfilename dump.rdb<br>#指定本地数据文件存放目录<br>dir /data<br>#指定日志文件位置(如果是相对路径，redis会将日志存放到指定的dir目录下)<br>logfile &quot;redis.log&quot;<br></code></pre></td></tr></table></figure><h4 id="编辑compose配置文件"><a href="#编辑compose配置文件" class="headerlink" title="编辑compose配置文件"></a>编辑compose配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi compose/docker-compose.yml<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.8&quot;</span><br><span class="hljs-attr">services:</span><br><span class="hljs-attr">redis:</span><br><span class="hljs-comment"># 指定镜像及版本</span><br><span class="hljs-attr">image:</span> <span class="hljs-string">redis:6.2.6</span><br><span class="hljs-comment"># 指定容器名</span><br><span class="hljs-attr">container_name:</span> <span class="hljs-string">fedora-redis</span><br><span class="hljs-comment"># 是否启动docker，自启动该容器</span><br><span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br><span class="hljs-comment"># 挂载 数据和配置持久化</span><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-comment"># 宿主机：容器 ro:docker容器对该文件只读，默认是rw可读可写</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">../redis.conf:/etc/redis/redis.conf:ro</span><br><span class="hljs-comment"># 宿主机：容器 数据</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">../data:/data</span><br><span class="hljs-comment"># 宿主机：容器 日志</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">../logs:/logs</span><br><span class="hljs-comment"># docker执行的启动命令</span><br><span class="hljs-attr">command:</span> <span class="hljs-string">redis-server</span> <span class="hljs-string">/etc/redis/redis.conf</span><br><span class="hljs-comment"># 端口映射</span><br><span class="hljs-attr">ports:</span><br><span class="hljs-bullet">-</span> <span class="hljs-number">6378</span><span class="hljs-string">:6379</span><br></code></pre></td></tr></table></figure><h4 id="docker-compose启动和关闭"><a href="#docker-compose启动和关闭" class="headerlink" title="docker-compose启动和关闭"></a><code>docker-compose</code>启动和关闭</h4><p>启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd compose<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动 -d 后台运行</span><br>docker-compose up -d<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动日志</span><br>[+] Running 7/7<br> ⠿ redis Pulled                                                                                                                                                           8.9s<br>   ⠿ 6d4a449ac69c Pull complete                                                                                                                                           4.4s<br>   ⠿ 29f18f34ea7f Pull complete                                                                                                                                           4.4s<br>   ⠿ c299869a5d25 Pull complete                                                                                                                                           4.5s<br>   ⠿ 57341d940d28 Pull complete                                                                                                                                           4.7s<br>   ⠿ 05c85b13ec38 Pull complete                                                                                                                                           4.8s<br>   ⠿ 5bc94d737d33 Pull complete <br>[+] Running 2/2<br> ⠿ Network compose_default  Created                                                                                                                                       0.1s<br> ⠿ Container fedora-redis   Started  <br></code></pre></td></tr></table></figure><p>出现如上的日志，那就证明我们的redis服务已经启动完毕了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看进程</span><br>ps -ef |grep redis<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看端口</span><br>netstat -ntlp<br><span class="hljs-meta prompt_"># </span><span class="language-bash">验证redis是否启动</span><br>docker exec -it fedora-redis redis-cli<br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入到redis客户端后，输入密码</span><br>auth 12345678<br></code></pre></td></tr></table></figure><p>查看redis容器的cpu和内存使用情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stats fedora-redis<br></code></pre></td></tr></table></figure><p>关闭服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">该命令会将容器直接删除</span><br>docker-compose down<br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以指定关闭redis服务（容器还在）</span><br>docker-compose stop redis<br></code></pre></td></tr></table></figure><h3 id="用docker-compose安装mysql"><a href="#用docker-compose安装mysql" class="headerlink" title="用docker-compose安装mysql"></a>用<code>docker-compose</code>安装<code>mysql</code></h3><h4 id="新建mysql相关的目录"><a href="#新建mysql相关的目录" class="headerlink" title="新建mysql相关的目录"></a>新建mysql相关的目录</h4><p><span style="color:blue">我们以安装<strong>mysql8.0</strong>为例</span></p><p>建立这些目录是为了让我们更好的管理和复用</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">mysql8<br>|---compose<br>|---docker-compose.yml      ---compose配置文件<br>|---data                          ---mysql数据存储目录（挂载用）<br>|---logs                          ---mysql日志文件目录<br>|---conf                          ---mysql配置目录<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir mysql &amp;&amp; cd mysql<br>mkdir compose data logs conf<br>touch compose/docker-compose.yml<br></code></pre></td></tr></table></figure><h4 id="编辑compose配置文件-1"><a href="#编辑compose配置文件-1" class="headerlink" title="编辑compose配置文件"></a>编辑compose配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi compose/docker-compose.yml<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.8&quot;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mysql8:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">fedora-mysql8</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">test</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">../data:/var/lib/mysql</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">../logs:/logs</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">../conf:/etc/mysql/conf.d</span><br>    <span class="hljs-attr">command:</span><br>      <span class="hljs-string">--default-authentication-plugin=mysql_native_password</span><br>      <span class="hljs-string">--character-set-server=utf8mb4</span><br>      <span class="hljs-string">--collation-server=utf8mb4_general_ci</span><br>      <span class="hljs-string">--explicit_defaults_for_timestamp=true</span><br>      <span class="hljs-string">--lower_case_table_names=1</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">3307</span><span class="hljs-string">:3306</span><br></code></pre></td></tr></table></figure><h4 id="启动mysql服务"><a href="#启动mysql服务" class="headerlink" title="启动mysql服务"></a>启动mysql服务</h4><p><img src="https://p.ipic.vip/exsgcy.png" alt="image-20230312102729438"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看服务日志</span><br>docker logs fedora-mysql8<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">连接mysql（输入密码即可）</span><br>docker exec -it fedora-mysql8 mysql -uroot -p<br></code></pre></td></tr></table></figure><p>进入到mysql客户端即成功。</p><h3 id="用Dockerfile构建服务镜像"><a href="#用Dockerfile构建服务镜像" class="headerlink" title="用Dockerfile构建服务镜像"></a>用<code>Dockerfile</code>构建服务镜像</h3><h4 id="第一种：直接用Dockerfile构建镜像"><a href="#第一种：直接用Dockerfile构建镜像" class="headerlink" title="第一种：直接用Dockerfile构建镜像"></a>第一种：直接用<code>Dockerfile</code>构建镜像</h4><h5 id="准备一个可执行jar（springboot）"><a href="#准备一个可执行jar（springboot）" class="headerlink" title="准备一个可执行jar（springboot）"></a>准备一个可执行jar（springboot）</h5><p>我们用一个简单的springboot可执行jar（<code>docker-jar-demo-0.0.1-SNAPSHOT.jar</code>）作为操作对象，这个jar只有一个get接口<code>/say</code>，返回<code>hello world</code></p><h5 id="创建一个Dockerfile"><a href="#创建一个Dockerfile" class="headerlink" title="创建一个Dockerfile"></a>创建一个<code>Dockerfile</code></h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">8</span>-jdk-alpine<br><span class="hljs-keyword">MAINTAINER</span> gcoder<br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> /tmp</span><br><span class="hljs-keyword">ARG</span> JAR_FILE<br><span class="hljs-keyword">COPY</span><span class="language-bash"> <span class="hljs-variable">$&#123;JAR_FILE&#125;</span> app.jar</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;-Xmx10m&quot;</span>,<span class="hljs-string">&quot;-Xms10m&quot;</span>,<span class="hljs-string">&quot;app.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure><h5 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">没有指定版本 默认是latest</span><br>docker build --build-arg JAR_FILE=./docker-jar-demo-0.0.1-SNAPSHOT.jar -t hello .<br></code></pre></td></tr></table></figure><h5 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker images<br></code></pre></td></tr></table></figure><h4 id="第二种：用maven插件和Dockerfile命令构建镜像"><a href="#第二种：用maven插件和Dockerfile命令构建镜像" class="headerlink" title="第二种：用maven插件和Dockerfile命令构建镜像"></a>第二种：用<code>maven</code>插件和<code>Dockerfile</code>命令构建镜像</h4><h5 id="在pom-xml添加docker插件"><a href="#在pom-xml添加docker插件" class="headerlink" title="在pom.xml添加docker插件"></a>在<code>pom.xml</code>添加<code>docker</code>插件</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.spotify<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>docker-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">imageName</span>&gt;</span>$&#123;project.name&#125;:$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">imageName</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">baseImage</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">baseImage</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">entryPoint</span>&gt;</span><br>            [&quot;java&quot;,&quot;-jar&quot;,&quot;-Xmx10m&quot;,&quot;-Xms10m&quot;,&quot;/$&#123;project.build.finalName&#125;.jar&quot;]<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">entryPoint</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">skipDockerBuild</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">skipDockerBuild</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="执行maven构建命令"><a href="#执行maven构建命令" class="headerlink" title="执行maven构建命令"></a>执行<code>maven</code>构建命令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mvn package docker:build<br></code></pre></td></tr></table></figure><h4 id="第三种：用maven插件读取Dockerfile进行构建"><a href="#第三种：用maven插件读取Dockerfile进行构建" class="headerlink" title="第三种：用maven插件读取Dockerfile进行构建"></a>第三种：用<code>maven</code>插件读取<code>Dockerfile</code>进行构建</h4><h5 id="在pom-xml添加docker插件-1"><a href="#在pom-xml添加docker插件-1" class="headerlink" title="在pom.xml添加docker插件"></a>在<code>pom.xml</code>添加<code>docker</code>插件</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.spotify<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>docker-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">imageName</span>&gt;</span>$&#123;project.name&#125;:$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">imageName</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dockerDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/docker<span class="hljs-tag">&lt;/<span class="hljs-name">dockerDirectory</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">skipDockerBuild</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">skipDockerBuild</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="在Dockefile指定路径建立Dockerfile文件"><a href="#在Dockefile指定路径建立Dockerfile文件" class="headerlink" title="在Dockefile指定路径建立Dockerfile文件"></a>在<code>Dockefile</code>指定路径建立<code>Dockerfile</code>文件</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">8</span>-jdk-alpine<br><span class="hljs-keyword">MAINTAINER</span> gcoder<br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> /tmp</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> docker-jar-demo-0.0.1-SNAPSHOT.jar app.jar</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;-Xmx10m&quot;</span>,<span class="hljs-string">&quot;-Xms10m&quot;</span>,<span class="hljs-string">&quot;app.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure><h5 id="执行maven构建命令-1"><a href="#执行maven构建命令-1" class="headerlink" title="执行maven构建命令"></a>执行<code>maven</code>构建命令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mvn package docker:build<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">容器技术在近些年是比较热门的，也适用于各种技术调研</summary>
    
    
    
    <category term="技术" scheme="https://gcoder5.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="docker" scheme="https://gcoder5.com/tags/docker/"/>
    
    <category term="centos" scheme="https://gcoder5.com/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>Java中的内存泄漏和内存溢出_下</title>
    <link href="https://gcoder5.com/2023/03/06/Java%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA_%E4%B8%8B/"/>
    <id>https://gcoder5.com/2023/03/06/Java%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA_%E4%B8%8B/</id>
    <published>2023-03-06T01:39:19.000Z</published>
    <updated>2023-03-11T06:18:09.813Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章我们一起学习了内存泄漏，那这一篇就收个尾，把内存溢出的内容讲一讲，提醒自己要记得，也分享给诸位。</p><p>在《Java虚拟机规范》的规定里，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生 OutOfMemoryError 异常的可能。</p><p><img src="https://p.ipic.vip/o5tmze.jpg" alt="img"></p><h3 id="java-lang-StackOverflowError"><a href="#java-lang-StackOverflowError" class="headerlink" title="java.lang.StackOverflowError"></a>java.lang.StackOverflowError</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackOverflowErrorDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        test();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        test();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Exception in thread &quot;main&quot; java.lang.StackOverflowError<br>at com.gcoder.memory.StackOverflowErrorDemo.javaKeeper(StackOverflowErrorDemo.java:24)<br></code></pre></td></tr></table></figure><h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4><ol><li>无限递归循环调用（最常见原因），要时刻注意代码中<strong>是否有了循环调用方法而无法退出的情况</strong></li><li>执行了大量方法，导致线程栈空间耗尽</li><li>方法内声明了海量的局部变量</li><li>native 代码有栈上分配的逻辑，并且要求的内存还不小，比如 java.net.SocketInputStream.read0 会在栈上要求分配一个 64KB 的缓存（64位 Linux）</li></ol><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li>修复引发无限递归调用的异常代码， 通过程序抛出的异常堆栈，找出不断重复的代码行，按图索骥，修复无限递归 Bug</li><li>排查是否存在类之间的循环依赖（当两个对象相互引用，在调用toString方法时也会产生这个异常）</li><li>通过 JVM 启动参数<code>-Xss</code>增加线程栈内存空间， 某些正常使用场景需要执行大量方法或包含大量局部变量，这时可以适当地提高线程栈空间限制</li></ol><h3 id="Java-heap-space"><a href="#Java-heap-space" class="headerlink" title="Java heap space"></a>Java heap space</h3><p>首先，我们都知道Java堆是用来存储对象实例的，当我们不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免GC清除这些对象，那么随着对象数量的增加，总容量达到堆的最大容量限制后就会出现内存溢出异常。</p><p>Java堆内存的OOM异常是实际应用中最常见的内存溢出异常。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JVM参数：-Xmx1m</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaHeapSpaceDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] a)</span> &#123;<br>        <span class="hljs-type">int</span>[] i = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[SIZE];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space<br>at com.gcoder.memory.JavaHeapSpaceDemo.main(JavaHeapSpaceDemo.java:22)<br></code></pre></td></tr></table></figure><h4 id="原因分析-1"><a href="#原因分析-1" class="headerlink" title="原因分析"></a>原因分析</h4><ol><li>请求创建一个<strong>超大</strong>对象，通常是一个大数组</li><li>超出预期的访问量&#x2F;数据量，通常是上游系统请求流量飙升，常见于各类促销&#x2F;秒杀活动，可以结合业务流量指标排查是否有尖状峰值</li><li>过度使用终结器（Finalizer），该对象没有立即被 GC</li><li>内存泄漏（Memory Leak），大量对象引用没有释放，JVM 无法对其自动回收，常见于使用了 File 等资源没有回收（资源没有释放）</li></ol><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>针对大部分情况，通常只需要通过 -Xmx 参数调高 JVM 堆内存空间即可。如果仍然没有解决，可以参考以下情况做进一步处理：</p><ol><li>如果是超大对象，可以检查其合理性，比如是否一次性查询了数据库全部结果，而没有做结果数限制</li><li>如果是业务峰值压力，可以考虑添加机器资源，或者做限流降级。</li><li>如果是内存泄漏，需要找到持有的对象，修改代码设计，比如关闭没有释放的连接</li></ol><h3 id="GC-overhead-limit-exceeded"><a href="#GC-overhead-limit-exceeded" class="headerlink" title="GC overhead limit exceeded"></a>GC overhead limit exceeded</h3><p>我们知道JVM 内置了垃圾回收机制GC，所以说我们开发过程中不需要通过手动来进行内存分配和回收，当我们的进程花费98% 以上的时间执行 GC，但只恢复了不到 2% 的内存，且该动作连续重复了 <strong>5</strong> 次，就会抛出 <code>java.lang.OutOfMemoryError:GC overhead limit exceeded </code>错误（俗称：<strong>垃圾回收上头</strong>）。简单地说，就是应用程序已经基本耗尽了所有可用内存， GC 也无法回收。</p><p>假如不抛出 GC overhead limit exceeded 错误，那 GC 清理的那么一丢丢内存很快就会被再次填满，迫使 GC 再次执行，这样恶性循环，CPU 使用率 100%，而 GC 没什么效果。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KeylessEntry</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Key</span> &#123;<br>        Integer id;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Key</span><span class="hljs-params">(Integer id)</span> &#123;<br>            <span class="hljs-built_in">this</span>.id = id;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> id.hashCode();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> (!m.containsKey(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Key</span>(i))) &#123;<br>                    m.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Key</span>(i), <span class="hljs-string">&quot;Number:&quot;</span> + i);<br>                &#125;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;m.size()=&quot;</span> + m.size());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">m.size()=94000<br>m.size()=95000<br>m.size()=96000<br>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded<br>at java.util.Arrays.copyOfRange(Arrays.java:3664)<br>at java.lang.String.&lt;init&gt;(String.java:207)<br>at java.lang.StringBuilder.toString(StringBuilder.java:412)<br>at com.gcoder.memory.KeylessEntry.main(KeylessEntry.java:40)<br></code></pre></td></tr></table></figure><h4 id="原因分析-2"><a href="#原因分析-2" class="headerlink" title="原因分析"></a>原因分析</h4><p>从输出结果可以看到，我们的限制 1000 条数据没有起作用，map 容量远超过了 1000，而且最后也出现了我们想要的错误，这是因为类 Key 只重写了 hashCode() 方法，却没有重写 equals() 方法，我们在使用 containsKey() 方法其实就出现了问题，于是就会一直往 HashMap 中添加 Key，直至 GC 都清理不掉。</p><p>执行这个程序的最终错误，和 JVM 配置也会有关系，如果设置的堆内存特别小，会直接报 Java heap space。算是被这个错误截胡了，所以有时，在资源受限的情况下，无法准确预测程序会死于哪种具体的原因。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li>添加 JVM 参数<code>-XX:-UseGCOverheadLimit</code> <span style="color:red"><strong>不推荐这么干</strong></span>，没有真正解决问题，只是将异常推迟</li><li>检查项目中是否有大量的死循环或有使用大内存的代码，优化代码</li><li>dump内存分析，检查是否存在内存泄露，如果没有，加大内存</li></ol><h3 id="Direct-buffer-memory"><a href="#Direct-buffer-memory" class="headerlink" title="Direct buffer memory"></a>Direct buffer memory</h3><p>我们使用 NIO 的时候经常需要使用 <code>ByteBuffer</code> 来读取或写入数据，这是一种基于<code> Channel</code>(通道) 和 <code>Buffer</code>(缓冲区)的 I&#x2F;O 方式，它可以使用<code> Native</code> 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里面的 <code>DirectByteBuffer</code> 对象作为这块内存的引用进行操作。这样在一些场景就避免了 Java 堆和 <code>Native </code>中来回复制数据，所以性能会有所提高。</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><blockquote><p><strong>ByteBuffer.allocate(capability)</strong> 是分配 JVM 堆内存，属于 GC 管辖范围，需要内存拷贝所以速度相对较慢；</p><p><strong>ByteBuffer.allocateDirect(capability)</strong> 是分配 OS 本地内存，不属于 GC 管辖范围，由于不需要内存拷贝所以速度相对较快；</p></blockquote><p>如果不断分配本地内存，堆内存很少使用，那么 JVM 就不需要执行 GC，DirectByteBuffer 对象就不会被回收，这时虽然堆内存充足，但本地内存可能已经不够用了，就会出现 OOM，本地直接内存溢出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * VM Options：-Xms10m,-Xmx10m,-XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectBufferMemoryDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;maxDirectMemory is:&quot;</span> + sun.misc.VM.maxDirectMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;MB&quot;</span>);<br>        <span class="hljs-comment">// ByteBuffer byteBuffer = ByteBuffer.allocate(6 * 1024 * 1024);</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(<span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">maxDirectMemory is:5MB<br>[GC (System.gc()) [PSYoungGen: 2535K-&gt;512K(4608K)] 2535K-&gt;737K(15872K), 0.0007841 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <br>[Full GC (System.gc()) [PSYoungGen: 512K-&gt;0K(4608K)] [ParOldGen: 225K-&gt;618K(11264K)] 737K-&gt;618K(15872K), [Metaspace: 3248K-&gt;3248K(1056768K)], 0.0022090 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] <br>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory<br>at java.nio.Bits.reserveMemory(Bits.java:695)<br>at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123)<br>at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)<br>at com.gcoder.memory.DirectBufferMemoryDemo.main(DirectBufferMemoryDemo.java:24)<br>Heap<br> PSYoungGen      total 4608K, used 394K [0x00000007bfb00000, 0x00000007c0000000, 0x00000007c0000000)<br>  eden space 4096K, 9% used [0x00000007bfb00000,0x00000007bfb62898,0x00000007bff00000)<br>  from space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000)<br>  to   space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)<br> ParOldGen       total 11264K, used 618K [0x00000007bf000000, 0x00000007bfb00000, 0x00000007bfb00000)<br>  object space 11264K, 5% used [0x00000007bf000000,0x00000007bf09a928,0x00000007bfb00000)<br> Metaspace       used 3479K, capacity 4496K, committed 4864K, reserved 1056768K<br>  class space    used 377K, capacity 388K, committed 512K, reserved 1048576K<br></code></pre></td></tr></table></figure><h4 id="原因分析-3"><a href="#原因分析-3" class="headerlink" title="原因分析"></a>原因分析</h4><p>最大直接内存，默认是电脑内存的 1&#x2F;4，所以我们设小点，然后使用直接内存超过这个值，就会出现 OOM。</p><h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li>Java 只能通过 <code>ByteBuffer.allocateDirect </code>方法使用<code> Direct ByteBuffer</code>，因此，可以通过 Arthas 等在线诊断工具拦截该方法进行排查</li><li>检查是否直接或间接使用了 NIO，如 netty，jetty 等</li><li>通过启动参数<code>-XX:MaxDirectMemorySize</code>调整 <code>Direct ByteBuffer </code>的上限值</li><li>检查 JVM 参数是否有<code>-XX:+DisableExplicitGC</code>选项，如果有就去掉，因为该参数会使 <code>System.gc() </code>失效</li><li>检查堆外内存使用代码，确认是否存在内存泄漏；或者通过反射调用<code> sun.misc.Cleaner</code>的<code> clean()</code> 方法来主动释放被 <code>Direct ByteBuffer </code>持有的内存空间</li><li>内存容量确实不足，升级配置</li></ol><h3 id="Unable-to-create-new-native-thread"><a href="#Unable-to-create-new-native-thread" class="headerlink" title="Unable to create new native thread"></a>Unable to create new native thread</h3><p><strong>每个 Java 线程都需要占用一定的内存空间</strong>，当 JVM 向底层操作系统请求创建一个新的 <code>native</code> 线程时，如果没有足够的资源分配就会报此类错误。</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeThreadMemoryDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(Integer.MAX_VALUE);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread<br>at java.lang.Thread.start0(Native Method)<br>at java.lang.Thread.start(Thread.java:719)<br>at com.gcoder.memory.NativeThreadMemoryDemo.main(NativeThreadMemoryDemo.java:27)<br>Error occurred during initialization of VM<br>java.lang.OutOfMemoryError: unable to create new native thread<br></code></pre></td></tr></table></figure><h4 id="原因分析-4"><a href="#原因分析-4" class="headerlink" title="原因分析"></a>原因分析</h4><p><img src="/Java%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%88%E4%B8%8B%EF%BC%89/resize,m_fixed,w_1184.png" alt="java 9种常见的OOM场景——原因分析及解决方案_Java教程_05"></p><p>JVM 向 OS 请求创建 <code>native</code> 线程失败，就会抛出 <code>Unableto createnewnativethread</code>，常见的原因包括以下几类:</p><ol><li>线程数超过操作系统最大线程数限制（和平台有关）</li><li>线程数超过 kernel.pid_max（只能重启）</li><li>native 内存不足；该问题发生的常见过程主要包括以下几步：<ol><li>JVM 内部的应用程序请求创建一个新的 Java 线程；</li><li>JVM native 方法代理了该次请求，并向操作系统请求创建一个 native 线程；</li><li>操作系统尝试创建一个新的 native 线程，并为其分配内存；</li><li>如果操作系统的虚拟内存已耗尽，或是受到 32 位进程的地址空间限制，操作系统就会拒绝本次 native 内存分配；</li><li>JVM 将抛出 java.lang.OutOfMemoryError:Unableto createnewnativethread 错误。</li></ol></li></ol><h4 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li>想办法降低程序中创建线程的数量，分析应用是否真的需要创建这么多线程（减少线程数）</li><li>如果确实需要创建很多线程，<strong>调高 OS 层面的线程最大数</strong>：执行<code> ulimia-a</code> 查看最大线程数限制，使用<code>ulimit-u xxx</code>调整最大线程数限制</li></ol><h3 id="Metaspace"><a href="#Metaspace" class="headerlink" title="Metaspace"></a>Metaspace</h3><p>JDK 1.8 之前会出现<code> Permgen space</code>，该错误表示永久代（<code>Permanent Generation</code>）已用满，通常是因为加载的 class 数目太多或体积太大。随着 <strong>1.8 中永久代的取消</strong>，就不会出现这种异常了。</p><p>Metaspace 是方法区在 HotSpot 中的实现，它与永久代最大的区别在于，元空间并不在虚拟机内存中而是使用本地内存，但是本地内存也有打满的时候，所以也会有异常。</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JVM Options: -XX:MetaspaceSize=1m -XX:MaxMetaspaceSize=1m</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        enhancer.setSuperclass(MetaspaceOOMDemo.class);<br>        enhancer.setUseCache(<span class="hljs-literal">false</span>);<br>        enhancer.setCallback((MethodInterceptor) (o, method, objects, methodProxy) -&gt; &#123;<br>            <span class="hljs-comment">//动态代理创建对象</span><br>            <span class="hljs-keyword">return</span> methodProxy.invokeSuper(o, objects);<br>        &#125;);<br>        enhancer.create();<br>    &#125;<br></code></pre></td></tr></table></figure><p>借助 Spring 的 GCLib 实现动态创建对象</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可能是因为我的环境是jdk8 所以没有复现</span><br>Error occurred during initialization of VM<br>MaxMetaspaceSize is too small.<br></code></pre></td></tr></table></figure><h4 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h4><p>方法区溢出也是一种常见的内存溢出异常，在经常运行时生成大量动态类的应用场景中，就应该特别关注这些类的回收情况。这类场景除了上边的 GCLib 字节码增强和动态语言外，常见的还有，大量 JSP 或动态产生 JSP  文件的应用（远古时代的传统软件行业可能会有）、基于 OSGi 的应用（即使同一个类文件，被不同的加载器加载也会视为不同的类）等。</p><p>方法区在 JDK8 中一般不太容易产生，HotSpot 提供了一些参数来设置元空间，可以起到预防作用:</p><p><code>-XX:MaxMetaspaceSize </code>设置元空间最大值，默认是 -1，表示不限制（还是要受本地内存大小限制的）</p><p><code>-XX:MetaspaceSize </code>指定元空间的初始空间大小，以字节为单位，达到该值就会触发 GC 进行类型卸载，同时收集器会对该值进行调整</p><p><code>-XX:MinMetaspaceFreeRatio</code> 在 GC 之后控制最小的元空间剩余容量的百分比，可减少因元空间不足导致的垃圾收集频率，类似的还有<code>MaxMetaspaceFreeRatio</code></p><h3 id="Requested-array-size-exceeds-VM-limit"><a href="#Requested-array-size-exceeds-VM-limit" class="headerlink" title="Requested array size exceeds VM limit"></a>Requested array size exceeds VM limit</h3><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[Integer.MAX_VALUE];<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Requested array size exceeds VM limit<br></code></pre></td></tr></table></figure><h4 id="原因分析-5"><a href="#原因分析-5" class="headerlink" title="原因分析"></a>原因分析</h4><ol><li>JVM 限制了数组的最大长度，该错误表示程序请求创建的数组超过最大长度限制。</li><li>JVM 在为数组分配内存前，会检查要分配的数据结构在系统中是否可寻址，通常为<code> Integer.MAX_VALUE-2</code>。</li></ol><h4 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li>此类问题比较罕见，通常需要检查代码，<strong>确认业务是否需要创建如此大的数组，是否可以拆分为多个块，分批执行</strong>。</li></ol><h3 id="Out-of-swap-space"><a href="#Out-of-swap-space" class="headerlink" title="Out of swap space"></a>Out of swap space</h3><p><strong>启动 Java 应用程序会分配有限的内存</strong>。此限制是通过<code>-Xmx</code>和其他类似的启动参数指定的。</p><p><span style="color:blue"><strong>在 JVM 请求的总内存大于可用物理内存的情况下，操作系统开始将内容从内存换出到硬盘驱动器</strong>。</span></p><p><img src="https://p.ipic.vip/8yblp0.jpg" alt="java 9种常见的OOM场景——原因分析及解决方案_Java教程_06"></p><p>该错误表示所有可用的虚拟内存已被耗尽。虚拟内存（Virtual Memory）由物理内存（Physical Memory）和交换空间（Swap Space）两部分组成。</p><h3 id="Kill-process-or-sacrifice-child"><a href="#Kill-process-or-sacrifice-child" class="headerlink" title="Kill process or sacrifice child"></a>Kill process or sacrifice child</h3><p>操作系统是建立在流程概念之上的。这些进程由几个内核作业负责，其中一个名为“ Out of memory Killer”，它会在可用内存极低的情况下“杀死”（kill）某些进程。OOM Killer 会对所有进程进行打分，然后将评分较低的进程“杀死”，具体的评分规则可以参考 Surviving the Linux OOM Killer。</p><p>不同于其他的 OOM 错误， Killprocessorsacrifice child 错误不是由 JVM 层面触发的，而是由操作系统层面触发的。</p><h4 id="原因分析-6"><a href="#原因分析-6" class="headerlink" title="原因分析"></a>原因分析</h4><p>默认情况下，<strong>Linux 内核允许进程申请的内存总量大于系统可用内存</strong>，通过这种“错峰复用”的方式可以更有效的利用系统资源。</p><p>然而，这种方式也会无可避免地带来一定的“<strong>超卖</strong>”风险。例如某些进程持续占用系统内存，然后导致其他进程没有可用内存。此时，<strong>系统将自动激活 OOM Killer，寻找评分低的进程，并将其“杀死”，释放内存资源</strong>。</p><h4 id="解决方案-7"><a href="#解决方案-7" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li>升级服务器配置&#x2F;隔离部署，避免争用</li><li>OOM Killer 调优。</li></ol><p><img src="https://p.ipic.vip/pnnftr.jpg" alt="java 9种常见的OOM场景——原因分析及解决方案_Java开发_08"></p><h3 id="搬运地址"><a href="#搬运地址" class="headerlink" title="搬运地址"></a>搬运地址</h3><p>本文内容引用以下大佬的文章，仅供学习参考，非赢利性质，如有侵权，请联系删除。</p><p><a href="https://blog.51cto.com/u_15257216/2861461">https://blog.51cto.com/u_15257216/2861461</a></p><p>希望小伙伴们能够自己撸一遍，也熟悉一下OOM的几种常见情况，有助于我们编写优质的代码。</p>]]></content>
    
    
    <summary type="html">内存泄漏的最终结果会导致内存溢出</summary>
    
    
    
    <category term="技术" scheme="https://gcoder5.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="https://gcoder5.com/tags/Java/"/>
    
    <category term="安全" scheme="https://gcoder5.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java中的内存泄漏和内存溢出_上</title>
    <link href="https://gcoder5.com/2023/03/04/Java%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA_%E4%B8%8A/"/>
    <id>https://gcoder5.com/2023/03/04/Java%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA_%E4%B8%8A/</id>
    <published>2023-03-04T12:29:28.000Z</published>
    <updated>2023-03-11T06:17:18.981Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们的目的很纯粹，就是来讲一下内存泄漏（<strong>memory leak</strong>）和内存溢出（<strong>out of memory</strong>）。很多时候，我们会听到这两个名词，但是系统的全面的了解却不多，所以今天我们就一起来学习学习。</p><h3 id="JVM如何判断对象是否健在"><a href="#JVM如何判断对象是否健在" class="headerlink" title="JVM如何判断对象是否健在"></a>JVM如何判断对象是否健在</h3><p>在讲内存之前呢，我们首先要知道这么一个问题：JVM是如何知道某个对象是否还健在的呢？我们都知道Java对象主要是存放在Java堆里的，所以当我们的GC（垃圾收集器）在对Java堆进行回收前，需要先确定这些对象是否还“存活”，哪些已经“死去”（不再被引用）。</p><p>下面我们就来讲几种用来判断对象是否健在的算法</p><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p><strong>对象中添加一个引用计数器，每有一个地方引用它时，计数器值就加一；当引用失效是，计数器值就减一；任何时刻计数器为零的对象就是不可以能再被使用的对象</strong>。</p><p>该算法的原理简单，判定效率高，但是我们目前主流的JVM并没有选用此算法来管理内存，主要是因为使用该算法时，需要配合大量的额外处理才能确保正确的工作，例如要解决<strong>对象之间的相互循环引用</strong>的问题，我们可以通过下面的代码例子来解答为啥不用的疑惑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MyTest</span> <span class="hljs-variable">myTest1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTest</span>();<br>        <span class="hljs-type">MyTest</span> <span class="hljs-variable">myTest2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTest</span>();<br><br>        myTest1.myTest = myTest2;<br>        myTest2.myTest = myTest1;<br><br>        myTest1 = <span class="hljs-literal">null</span>;<br>        myTest2 = <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-comment">// 假设在这行发生GC，test1和test2是否能被回收？</span><br>        System.gc();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">MyTest</span> <span class="hljs-variable">myTest</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析代码，myTest1和myTest2对象都被设置成了null，在后面发生GC的时候，如果按照引用计数算法，这两个对象虽然都被设置成了null，但是<strong>myTest1引用了myTest2，myTest2又引用了myTest1，所以这两个对象的引用计数值都不为0，所以都不会被回收</strong>，但是真正的实际运行结果是，这两个对象都被回收了，这也说明HotSpot虚拟机并不是用引用计数法来进行的内存管理。</p><p>那JVM用的是什么算法吗？我们继续往下看…</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>这个算法的基本思路就是通过一一系列称为<code>GC Roots</code> 的根对象作为起始节点集，从这些节点开始根据引用关系向下搜索，搜索走过的的路径称为“<strong>引用链</strong>”（Reference Chain）,如果某个对象到<code>GC Roots </code>间没有任何引用链相连，或者从<code>GC Roots</code> 到这个对象不可达时，则证明此对象是不可能再被使用的。</p><p><span style="color:blue"><strong>当前主流的商用程序语言（Java、C#等），都是通过可达性分析（Reachability Analysis）算法来判断对象是否存活的。</strong></span></p><p>我们可以来看下下面的图，<strong>虽然object10、object11、object12互相有关联，但是它们到GC Roots是不可达的，因此它们会被判定为可回收的对象。</strong></p><p><img src="https://p.ipic.vip/v4cky0.png" alt="可达性分析算法"></p><p>在Java程序中，固定可作为GC Roots 的对象包括以下几种：</p><ol><li><p>虚拟机栈中引用的对象</p><p>比如：各个线程被调用的方法中使用到的参数、局部变量等。</p></li><li><p>本地方法栈内JNI（通常说的本地方法）引用的对象</p></li><li><p>方法区中类静态属性引用的对象</p><p>比如：Java类的引用类型静态变量</p></li><li><p>方法区中常量引用的对象</p><p>比如：字符串常量池（string Table） 里的引用</p></li><li><p>所有被同步锁synchronized持有的对象</p></li><li><p>Java虚拟机内部的引用</p><p>比如：基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError） ，系统类加载器。</p></li><li><p>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</p></li><li><p>除了这些固定的GCRoots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。</p><p>比如：分代收集和局部回收（Partial GC）</p></li></ol><p>通过对上面两种算法的介绍，实际上在我们判断一个对象是否存在的依据，离不开这个对象是否被<strong>引用</strong>离不开关系。</p><p>在JDK1.2之前，Java对引用的概念是：如果reference类型的数据中存储的数值代表的是另外一块儿内存的地址，就称该reference数据是代表某块内存、某个对象的引用</p><p>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为<code>强引用（Strongly Reference）</code>、<code>软引用（Soft Reference）</code>、<code>弱引用（Weak Reference）</code>、<code>虚引用（Phantom Reference）</code>4种，*<em>这4种引用强度依次逐渐减弱</em></p><p>对于这四种不同的引用方式，我们做一个基本的介绍：</p><p><img src="/Java%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%88%E4%B8%8A%EF%BC%89/%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.png" alt="引用类型"></p><ol><li><p><strong>强引用</strong>是传统“引用”的定义，指引用复制，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><p>这种引用关系。无论在任何情况下，<strong>只要强引用关系还存在，垃圾收集器就不会回收掉被引用的对象</strong>。</p></li><li><p><strong>软引用</strong>是用来描述一些还有用，但非必须的对象。在系统发生内存溢出前，会先对软引用对象进行第二次回收，如果回收后还没有足够的内存，才会抛出内存溢出的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-type">ReferenceQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>();<br><span class="hljs-type">SoftReference</span> <span class="hljs-variable">reference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>(obj, queue);<br><span class="hljs-comment">// 强引用对象滞空，保留软引用</span><br>obj = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>弱引用</strong>也是用来描述那些非必须的对象，但是它的强度比软引用更弱一些，弱引用的对象，只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p><p>而<strong>弱引用和软引用的区别</strong>在于：弱引用的对象拥有更短的生命周期，只要垃圾回收器扫描到它，不管内存空间充足与否，都会回收它的内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-type">ReferenceQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>();<br><span class="hljs-type">WeakReference</span> <span class="hljs-variable">reference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>(obj, queue);<br><span class="hljs-comment">//强引用对象滞空，保留软引用</span><br>obj = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>虚引用</strong>也称为“幽灵引用”或“幻影引用”，它是最弱的一种引用关系。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</p></li></ol><p>综上来理解的话，通过定义四种引用类型以及可达性分析算法来判断对象是否健在。但是，是不是被可达性分析算法判断为不可达对象就“非死不可”了，实际上，要真正回收一个对象，是需要至少经历两次标记过程：</p><ol><li>如果第一次对象在进行可达性分析后发现与GC Roots 不可达，将进行第一次标记。</li><li>随后对此对象进行一次是否有必要执行<code>finalize()</code>方法进行筛选，假如对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机调用过，都视为“没有必要执行”。</li></ol><blockquote><p>如果对象被判定有必要执行finalize()方法，会将对象放置在一个名为F-Queue的队列中，并在由一条由虚拟机自动建立的、低调度的线程区执行它们的finalize()方法。但并不承诺一定会等待它们运行结束。</p></blockquote><p><span style="color:red"><strong>注意事项：</strong></span>任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临第二次回收，它的finalize()方法不会被再次执行。<br><strong>还有一点就是Java官方已经明确声明不推荐手动调用finalize()方法了，因为它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，并且finanlize()能做的所有工作，使用try-finally或其他方式都可以做的更好、更及时。</strong></p><h3 id="什么是内存泄漏（memory-leak）"><a href="#什么是内存泄漏（memory-leak）" class="headerlink" title="什么是内存泄漏（memory leak）"></a>什么是内存泄漏（memory leak）</h3><p>学习完了上面的对象回收之后，我们接下来就讲一下什么是内存泄漏。</p><p>在用可达性分析算法判断对象是否是不再使用的对象时，本质都是判断一个对象是否还被引用。那么对于这种情况下，由于代码的实现不同就会出现很多内存泄漏问题（让JVM误以为此对象还在引用中，无法回收，造成内存泄漏）。</p><p>主要关注两点：</p><ol><li>是否还被使用？是</li><li>是否还被需要？否</li></ol><h3 id="内存泄漏（memory-leak）的理解"><a href="#内存泄漏（memory-leak）的理解" class="headerlink" title="内存泄漏（memory leak）的理解"></a>内存泄漏（memory leak）的理解</h3><p>严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。但实际情况很多时候一些不太好的实践（或疏忽）才导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。</p><h3 id="内存泄漏和内存溢出的关系"><a href="#内存泄漏和内存溢出的关系" class="headerlink" title="内存泄漏和内存溢出的关系"></a>内存泄漏和内存溢出的关系</h3><p>内存泄漏（memory leak）就是<strong>占着茅坑不拉屎</strong>，明明申请了内存并使用完了但是就是不释放掉。比如一共有1024M的内存，分配了512M的内存一直不回收，那么可用的内存就只有512M了，仿佛漏掉了一部分。</p><p>内存溢出（out of memory）就是申请内存的时候，没有足够的内存可以使用。通俗一点儿讲，一个厕所就三个坑，有两个站着茅坑不走的（内存泄漏），剩下最后一个坑，厕所表示接待压力很大，这时候一下子来了两个人，坑位（内存）就不够了，内存泄漏变成了内存溢出了。</p><p>所以，内存泄漏的增多，最终会导致内存溢出。</p><h3 id="内存泄漏的分类"><a href="#内存泄漏的分类" class="headerlink" title="内存泄漏的分类"></a>内存泄漏的分类</h3><ol><li>经常发生：发生内存泄漏的代码会被多次执行，每次执行，泄漏一块内存；</li><li>偶然发生：在某些特定情况下才会发生；</li><li>一次性：发生内存泄漏的方法只会执行一次；</li><li>隐式泄漏：一直占着内存不释放，直到执行结束；严格的说这个不算内存泄漏，因为最终释放掉了。</li></ol><h3 id="常见的内存泄漏8种情况"><a href="#常见的内存泄漏8种情况" class="headerlink" title="常见的内存泄漏8种情况"></a>常见的内存泄漏8种情况</h3><h4 id="1-静态集合类"><a href="#1-静态集合类" class="headerlink" title="1.静态集合类"></a>1.静态集合类</h4><p>静态集合类，如HashMap、LinkedList等等。<strong>如果这些容器为静态的，那么它们的声明周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏</strong>。简单而言，长生命周期的对象有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryLeak</span> &#123;<br>   <span class="hljs-keyword">static</span> <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">oomTests</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">// 局部变量</span><br>       list.add(obj);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-各种连接使用后未关闭"><a href="#2-各种连接使用后未关闭" class="headerlink" title="2.各种连接使用后未关闭"></a>2.<strong>各种连接使用后未关闭</strong></h4><p>如数据库连接、网络 http 连接、io 连接等等。当程序操作数据库时，首先应该建立数据库的连接 Connection，操作语句时建立 Statement 对象，获取结果集建立 ResultSet 对象，之后需要显示的调用 close 方法来关闭连接，只有关闭连接后，GC 才会对对应的未使用对象进行回收。<strong>没有及时的关闭数据库连接，会导致大量对象长期占用内存空间，导致内存泄漏</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>   <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-变量的作用域不合理"><a href="#3-变量的作用域不合理" class="headerlink" title="3.变量的作用域不合理"></a>3.<strong>变量的作用域不合理</strong></h4><p>如本该唯一定义在某方法的变量定义在了全局变量。一般来讲，<strong>一个变量的作用范围大于其所被使用的范围，可能发生内存泄漏</strong>，表现在存在时间大于使用时间，即使用完了但是还不能被回收，就比如下面的列子。另外，如果没有及时的将未使用的对象置 null，也有可能导致内存泄漏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.gcoder.common.core;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存泄漏例子</span><br><span class="hljs-comment"> * 这里的变量 info 在方法 receiveAndSaveInfo 中进行赋值和保存，在该方法执行完毕后本应该被 GC 回收，</span><br><span class="hljs-comment"> * 但由于全局变量的生命周期是跟随对象的，所有当方法执行完不能被回收，可能造成内存泄漏。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> gcoder</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoMemoryLeak</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 消息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String info;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveAndSaveInfo</span><span class="hljs-params">()</span> &#123;<br>        <br>        <span class="hljs-comment">// 模拟接受消息</span><br>        receiveInfo();<br>        <br>        <span class="hljs-comment">// 模拟存储消息</span><br>        saveInfo();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-内部类持有外部类"><a href="#4-内部类持有外部类" class="headerlink" title="4.内部类持有外部类"></a>4.<strong>内部类持有外部类</strong></h4><p>如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。</p><h4 id="5-改变哈希值"><a href="#5-改变哈希值" class="headerlink" title="5.改变哈希值"></a>5.改变哈希值</h4><p>当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希值就不同了，在这种情况下，即使在 contains 方法使用该对象的当前引用作为的参数去 HashSet 集合中检索对象，也将返回找不到对象的结果，这也会导致无法从 HashSet 集合中单独删除当前对象，造成内存泄露。</p><h4 id="6-栈引起的内存泄漏"><a href="#6-栈引起的内存泄漏" class="headerlink" title="6.栈引起的内存泄漏"></a>6.<strong>栈引起的内存泄漏</strong></h4><p>我们可以编辑一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoMemoryLeak</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">private</span> Object[] elements;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoMemoryLeak</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.elements = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[DEFAULT_INITIAL_CAPACITY];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 进栈</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o o</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> gaohuiwu</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@date</span> 2023-03-05</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(Object o)</span> &#123;<br>        ensureCapacity();<br>        elements[size++] = o;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 出栈</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> lang.Object</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> gaohuiwu</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@date</span> 2023-03-05</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmptyStackException</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> elements[--size];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 扩容</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> gaohuiwu</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@date</span> 2023-03-05</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (elements.length == size) &#123;<br>            elements = Arrays.copyOf(elements, size * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段模拟栈操作的代码存在隐蔽的内存泄漏问题。定位到pop()函数，在return语句中，当我们弹出一个元素时，只是简单的让栈顶指针（size）-1。逻辑上，栈中的这个元素已经弹出，已经没有用了。但是事实上，<strong>被弹出的元素依然存在于elements数组中</strong>，它依然被elements数组所引用，GC是无法回收被引用着的对象的。也许你期望等这整个栈失去引用（将被GC回收时），栈内的elements数组一起被GC回收。但是实际的使用过程中，又有谁能够预料到这个栈会存活多长时间。为了保险起见，我们需要在弹出一个元素的时候，就让这个元素失去引用，便于GC回收。我们只需要让Pop()函数弹出时，同时解除对弹出元素的引用即可。</p><h4 id="7-缓存泄漏"><a href="#7-缓存泄漏" class="headerlink" title="7.缓存泄漏"></a>7.缓存泄漏</h4><p>内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘，对于这个问题，可以使用<code>WeakHashMap</code>代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值。</p><h4 id="8-监听器和回调"><a href="#8-监听器和回调" class="headerlink" title="8.监听器和回调"></a>8.监听器和回调</h4><p>内存泄漏第三个常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显示的取消，那么就会积聚。需要确保回调立即被当作垃圾回收的最佳方法是只保存他的若引用，例如将他们保存成为WeakHashMap中的键。</p><h3 id="预防内存泄漏的方法"><a href="#预防内存泄漏的方法" class="headerlink" title="预防内存泄漏的方法"></a>预防内存泄漏的方法</h3><ol><li>尽量减少使用静态变量，或者使用完及时赋值为 null</li><li>明确内存对象的有效作用域，<strong>尽量缩小对象的作用域</strong>，能用局部变量处理的不用成员变量，因为局部变量弹栈会自动回收</li><li>减少长生命周期的对象持有短生命周期的引用</li><li>使用 <code>StringBuilder</code> 和<code>StringBuffer</code>进行字符串连接，<code>Sting</code> 和<code> StringBuilder</code> 以及 <code>StringBuffer </code>等都可以代表字符串，其中 <code>String </code>字符串代表的是不可变的字符串，后两者表示可变的字符串。如果使用多个<code>String</code>对象进行字符串连接运算，在运行时可能产生大量临时字符串，这些字符串会保存在内存中从而导致程序性能下降</li><li>对于不需要使用的对象手动设置 null 值，不管 GC 何时会开始清理，我们都<strong>应及时的将无用的对象标记为可被清理的对象</strong></li><li>各种连接（数据库连接，网络连接，IO连接）操作，务必显示调用close关闭</li></ol><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>本文我们一起学习了jvm的回收机制和内存泄漏的一些场景和预防措施，那么下个篇幅，我们就来讲讲所谓的内存溢出～</p><hr><p>我是Gcoder，一个热爱学习的Java跑马选手。</p>]]></content>
    
    
    <summary type="html">敲一段代码很简单，但是要敲好代码并不容易。今天我们来讲关于内存这一块～</summary>
    
    
    
    <category term="技术" scheme="https://gcoder5.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="https://gcoder5.com/tags/Java/"/>
    
    <category term="安全" scheme="https://gcoder5.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>认识下Java8的日期时间类</title>
    <link href="https://gcoder5.com/2023/03/03/%E8%AE%A4%E8%AF%86%E4%B8%8BJava8%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B1%BB/"/>
    <id>https://gcoder5.com/2023/03/03/%E8%AE%A4%E8%AF%86%E4%B8%8BJava8%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B1%BB/</id>
    <published>2023-03-03T15:19:25.000Z</published>
    <updated>2023-03-04T04:44:59.399Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>技术是无止境的，这些年搁置了博客。但没忘记学习，这段时间先把之前的笔记更新出来，此后我们再一道来谈谈近些年的一些新玩意儿！</p></blockquote><h3 id="从Date类开始讲起"><a href="#从Date类开始讲起" class="headerlink" title="从Date类开始讲起"></a>从Date类开始讲起</h3><p>Date这个类，我们应该都不陌生，因为我们经常用<code>new Date()</code>来获取当前的时间。而对于Date类来说呢，我们需要有这么两个认知。</p><ol><li><p>Date不存在时区的问题，也就是说<strong>世界上的任何一台计算机编写<code>new Date()</code>执行之后得到的都是同样的时间</strong>。</p><p>原因我也解释一下，因为Date中保存的是<code>UTC</code>时间，<code>UTC</code>时间是以原子钟为基础的统一时间，不以时间参照计时，所以不存在时区的划分。</p></li><li><p>Date中保存的是一个时间戳，代表的是从1970年1月1日0点（Epoch时间）到现在的毫秒数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">0</span>));<br>System.out.println(TimeZone.getDefault().getID() + <span class="hljs-string">&quot;:&quot;</span> + TimeZone.getDefault().getRawOffset()/<span class="hljs-number">3600000</span>);<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">输出内容</span><br>Thu Jan 01 08:00:00 CST 1970<br>Asia/Shanghai:8<br></code></pre></td></tr></table></figure></li></ol><h3 id="日期时间该怎么保存呢"><a href="#日期时间该怎么保存呢" class="headerlink" title="日期时间该怎么保存呢"></a>日期时间该怎么保存呢</h3><p>因为有时区的影响，所以对于不同的日期形式有不同的方式来进行保存。</p><ol><li><p>以UTC保存，保存的时间没有时区属性，是不涉及时区时间差问题的世界统一时间。<strong>时间戳</strong>或Java中的<strong>Date类</strong>就是这种方式，也是推荐的方式。</p></li><li><p>以字符串的形式保存，比如年&#x2F;月&#x2F;日 时:分:秒，一定要同时<strong>保存时区信息</strong>。</p><p>有时区信息，才能知道这个字符串时间真正的时间点。Calendar 是有时区概念的，所以我们通过不同的时区初始化 Calendar，得到了不同的时间。</p></li></ol><h3 id="关于字符串和Date的相互转换"><a href="#关于字符串和Date的相互转换" class="headerlink" title="关于字符串和Date的相互转换"></a>关于字符串和Date的相互转换</h3><ol><li><p>对于同一个时间表示，比如2023-03-03 22:00:00，不同时区的人转换成Date会得到不同的时间（时间戳）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">stringDate</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2023-03-03 22:00:00&quot;</span>;<br><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">inputFormat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><span class="hljs-comment">// 默认时区解析时间表示</span><br><span class="hljs-type">Date</span> <span class="hljs-variable">date1</span> <span class="hljs-operator">=</span> inputFormat.parse(stringDate);<br>System.out.println(date1 + <span class="hljs-string">&quot;:&quot;</span> + date1.getTime());<br><span class="hljs-comment">// 纽约时区解析时间表示</span><br>inputFormat.setTimeZone(TimeZone.getTimeZone(<span class="hljs-string">&quot;Asia/Shanghai&quot;</span>));<br><span class="hljs-type">Date</span> <span class="hljs-variable">date2</span> <span class="hljs-operator">=</span> inputFormat.parse(stringDate);<br>System.out.println(date2 + <span class="hljs-string">&quot;:&quot;</span> + date2.getTime());<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">输出内容</span><br>Fri Mar 03 22:00:00 CST 2023:1677852000000<br>Fri Mar 03 22:00:00 CST 2023:1677852000000<br></code></pre></td></tr></table></figure></li><li><p>不同时区下格式化得到的不同的时间表示，比如当前时区和纽约时区的时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">stringDate</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2023-03-03 22:00:00&quot;</span>;<br><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">inputFormat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><span class="hljs-type">Date</span> <span class="hljs-variable">date1</span> <span class="hljs-operator">=</span> inputFormat.parse(stringDate);<br><span class="hljs-type">String</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;[yyyy-MM-dd HH:mm:ss Z]&quot;</span>).format(date1);<br>System.out.println( format);<br>TimeZone.setDefault(TimeZone.getTimeZone(<span class="hljs-string">&quot;America/New_York&quot;</span>));<br><span class="hljs-type">String</span> <span class="hljs-variable">format1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;[yyyy-MM-dd HH:mm:ss Z]&quot;</span>).format(date1);<br>System.out.println(format1);<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[2023-03-03 22:00:00 +0800]<br>[2023-03-03 09:00:00 -0500]<br></code></pre></td></tr></table></figure><p><span style="color:red"><strong>注意事项：</strong></span>有时候数据库相同的时间，由于<strong>服务器的时区</strong>设置不同，读取到的时间表示不同。这正是时区发挥作用了，因为UTC时间需要根据当前时区解析正确的本地时间。</p></li></ol><h3 id="Java8的时间日期类"><a href="#Java8的时间日期类" class="headerlink" title="Java8的时间日期类"></a>Java8的时间日期类</h3><p>对于Java8而言，Java8对于日期的处理发生了巨大的改变，以下我们就一起来学习一下。</p><ol><li><p>初始化时区的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化标准的时区</span><br>ZoneId.of(<span class="hljs-string">&quot;Asia/Shanghai&quot;</span>);<br><span class="hljs-comment">// 初始化一个具有指定时间差的自定义时区</span><br>ZoneOffset.ofHour()<br></code></pre></td></tr></table></figure></li><li><p><code>LocalDateTime</code>不带有时区属性，所以它只是一个时间表示，命名为本地时区的日期时间；ZonedDateTime&#x3D;LocalDateTime+ZoneId，具有时区性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> ZonedDateTime.of(LocalDateTime.parse(stringDate, dateTimeFormatter), timeZoneJST);<span class="hljs-comment">//使用DateTimeFormatter格式化时间，可以通过withZone方法直接设置格式化使用的时区DateTimeFormatter outputFormat = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss Z&quot;);System.out.println(timeZoneSH.getId() + outputFormat.withZone(timeZoneSH).format(date));System.out.println(timeZoneNY.getId() + outputFormat.withZone(timeZoneNY).format(date));System.out.println(timeZoneJST.getId() + outputFormat.withZone(timeZoneJST).format(date));</span><br></code></pre></td></tr></table></figure></li><li><p>使用<code>DateTimeFormatter</code>格式化时间的时候，可以直接通过withZone方法直接设置格式化使用的时区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(timeZoneJST.getId() + outputFormat.withZone(timeZoneJST).format(date));<br></code></pre></td></tr></table></figure><p><span style="color:red"><strong>注意事项：</strong></span>要正确处理国际化时间问题，使用Java8的日期时间类，即使用ZonedDateTime保存时间，然后使用设置了ZoneId的DateTimeFormatter配合ZonedDateTime进行时间格式化得到本地时间表示。</p></li></ol><h3 id="不建议继续使用SimpleDateFormat"><a href="#不建议继续使用SimpleDateFormat" class="headerlink" title="不建议继续使用SimpleDateFormat"></a>不建议继续使用<code>SimpleDateFormat</code></h3><h4 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h4><p>在我们对于日期进行格式化的时候，在Java8之前我们经常用使用<code>SimpleDateFormat</code>来进行格式化，实际上<code>SimpleDateFormat</code>是线程不安全的，所以并不推荐使用。</p><p>我们可以通过源码来解读下为啥<code>SimpleDateFormat</code>是线程不安全的。首先，我们目光聚焦到官网的一段话：</p><blockquote><p>Synchronization<br>Date formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally.</p></blockquote><p>大致意思就是说：这个玩意儿线程不安全，如果要用在多线程，最好是每个线程有各自的<code>SimpleDateFormat</code>对象；如果在并发环境下使用SimpleDateFormat对象，需要进行同步串行。</p><p>下面，我们一起来看下源码，正常情况，我们使用<code>parse()</code>和<code>format()</code>两个函数比较多，所以我们那就来看看关于这两个函数的实现</p><p><code>SimpleDateFormat</code>的<code>parse()</code>局部源码</p><p><img src="https://p.ipic.vip/gkxat4.png" alt="image-20230304000439390"></p><p><code>SimpleDateFormat</code>的<code>format()</code>局部源码</p><p><img src="https://p.ipic.vip/w5aa4n.png" alt="image-20230304000547953"></p><p>从上面的两个函数的局部代码，我们可以看到两函数有共用一个成员变量<code>calendar</code>，那么这个变量是怎么定义的呢？实际上，它是父类<code>DateFormat</code>的一个普通的成员变量。</p><p><img src="https://p.ipic.vip/28kh4z.png" alt="image-20230304000741733"></p><p>综上，parse与format方法，是共用一个calendar成员变量的，所以如果多线程共用SimpleDateFormat对象，即使A线程做format操作，B线程做parse操作，也会存在并发问题，所以它是线程不安全的。</p><p>假如我们真的需要使用到<code>SimpleDateFormat</code>，那我们可以定义一个线程变量来解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; threadSafeSimpleDateFormat = ThreadLocal.withInitial(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));<br></code></pre></td></tr></table></figure><h4 id="转换太宽容"><a href="#转换太宽容" class="headerlink" title="转换太宽容"></a>转换太宽容</h4><p>为什么说<code>SimpleDateFormat</code>转换太宽容，那是因为尽管需要解析的字符串和<code>SimpleDateFormat</code>指定的格式不匹配，但是其进行转换后还是能够得到结果，这样会导致我们在业务处理上，获取到错误的结果，从而引发难以定位的业务异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 例：用yyyyMM来解析20230303字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">dateString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;20230303&quot;</span>;<br><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">dateFormat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyyMM&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;result:&quot;</span> + dateFormat.parse(dateString));<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">原因是把0303当成了月份，相当于25年(303/12)</span><br>result:Sun Mar 01 00:00:00 CST 2048<br></code></pre></td></tr></table></figure><h3 id="Java8是如何规避SimleDateFormat的坑"><a href="#Java8是如何规避SimleDateFormat的坑" class="headerlink" title="Java8是如何规避SimleDateFormat的坑"></a>Java8是如何规避SimleDateFormat的坑</h3><p>Java8对日期进行格式化是用的<code>DateTimeFormatter</code>这个类来处理，而这个类也规避了<code>SimleDateFormat</code>带来的问题。</p><ol><li><p>使用 <code>DateTimeFormatterBuilder</code> 来定义格式化字符串，不用去记忆使用大写的 Y 还是小写的 Y，大写的 M 还是小写的 m</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dateTimeFormatter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DateTimeFormatterBuilder</span>()<br>        .appendValue(ChronoField.YEAR) <span class="hljs-comment">//年</span><br>        .appendLiteral(<span class="hljs-string">&quot;/&quot;</span>)<br>        .appendValue(ChronoField.MONTH_OF_YEAR) <span class="hljs-comment">//月</span><br>        .appendLiteral(<span class="hljs-string">&quot;/&quot;</span>)<br>        .appendValue(ChronoField.DAY_OF_MONTH) <span class="hljs-comment">//日</span><br>        .appendLiteral(<span class="hljs-string">&quot; &quot;</span>)<br>        .appendValue(ChronoField.HOUR_OF_DAY) <span class="hljs-comment">//时</span><br>        .appendLiteral(<span class="hljs-string">&quot;:&quot;</span>)<br>        .appendValue(ChronoField.MINUTE_OF_HOUR) <span class="hljs-comment">//分</span><br>        .appendLiteral(<span class="hljs-string">&quot;:&quot;</span>)<br>        .appendValue(ChronoField.SECOND_OF_MINUTE) <span class="hljs-comment">//秒</span><br>        .appendLiteral(<span class="hljs-string">&quot;.&quot;</span>)<br>        .appendValue(ChronoField.MILLI_OF_SECOND) <span class="hljs-comment">//毫秒</span><br>        .toFormatter();<br></code></pre></td></tr></table></figure></li><li><p>DateTimeFormatter 是线程安全的，可以定义为 static 使用</p></li><li><p>DateTimeFormatter 的解析比较严格，需要解析的字符串和格式不匹配时，会直接报错，而不会把 0303 解析为月份</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用刚才定义的DateTimeFormatterBuilder构建的DateTimeFormatter来解析这个时间</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime</span> <span class="hljs-operator">=</span> LocalDateTime.parse(<span class="hljs-string">&quot;2023/3/3 12:00:00.789&quot;</span>, dateTimeFormatter);<br><span class="hljs-comment">// 解析成功</span><br>System.out.println(localDateTime.format(dateTimeFormatter));<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">2023/3/3 12:0:0.789<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用yyyyMM格式解析20230303是否可以成功呢？</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">dt</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;20230303&quot;</span>;<br>        <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dateTimeFormatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyyMM&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;result:&quot;</span> + dateTimeFormatter.parse(dt));<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">Exception in thread &quot;main&quot; java.time.format.DateTimeParseException: Text &#x27;20230303&#x27; could not be parsed at index 0<br>at java.time.format.DateTimeFormatter.parseResolved0(DateTimeFormatter.java:1949)<br>at java.time.format.DateTimeFormatter.parse(DateTimeFormatter.java:1777)<br>at com.tansun.MySqlCall.main(MySqlCall.java:121)<br></code></pre></td></tr></table></figure></li></ol><h3 id="Java8日期时间的计算"><a href="#Java8日期时间的计算" class="headerlink" title="Java8日期时间的计算"></a>Java8日期时间的计算</h3><p>通常我们在日常开发中会需要对时间进行计算，比如算一下今天起之后30天的时间，一般而言，我们会直接把Date().getTime 方法得到的时间戳加 30 天对应的毫秒数，也就是 30 天 *1000 毫秒 *3600 秒 *24 小时。但是这样就导致时间计算的错误，因为int会溢出，所以我们需要将30修正为30L。</p><p>在Java8之前，我们要进行日期时间计算的话，更推荐用<code>Calendar</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calendar</span> <span class="hljs-variable">calendar</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>calendar.setTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>calendar.add(Calendar.DAY_OF_MONTH,<span class="hljs-number">30</span>);<br>System.out.println(calendar.getTime());<br></code></pre></td></tr></table></figure><p>接下来，我们就来说说Java8对日期时间的计算操作</p><ol><li><p>使用各种<code>minus</code>和<code>plus</code>方法直接对日期进行加减操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// minus-减  plus-加</span><br>System.out.println(<span class="hljs-string">&quot;测试操作日期&quot;</span>);<br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">localDate</span> <span class="hljs-operator">=</span> LocalDate.now()<br>     .minus(Period.ofDays(<span class="hljs-number">1</span>))<br>     .plus(<span class="hljs-number">12</span>, ChronoUnit.DAYS)<br>     .minusMonths(<span class="hljs-number">1</span>)<br>     .plus(Period.ofMonths(<span class="hljs-number">1</span>));<br>System.out.println(<span class="hljs-string">&quot;localDate = &quot;</span> + localDate);<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">测试操作日期<br>localDate = 2023-03-15<br></code></pre></td></tr></table></figure></li><li><p>通过<code>with</code>方法进行快捷时间调节</p><ol><li>使用 TemporalAdjusters.firstDayOfMonth 得到当前月的第一天；</li><li>使用 TemporalAdjusters.firstDayOfYear() 得到当前年的第一天；</li><li>使用 TemporalAdjusters.previous(DayOfWeek.SATURDAY) 得到上一个周六；</li><li>使用 TemporalAdjusters.lastInMonth(DayOfWeek.FRIDAY) 得到本月最后一个周五。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;本月的第一天&quot;</span>);<br>System.out.println(LocalDate.now().with(TemporalAdjusters.firstDayOfMonth()));<br>System.out.println(<span class="hljs-string">&quot;今年的程序员日&quot;</span>);<br>System.out.println(LocalDate.now().with(TemporalAdjusters.firstDayOfYear()).plusDays(<span class="hljs-number">357</span>));<br>System.out.println(<span class="hljs-string">&quot;今天之前的一个周六&quot;</span>);<br>System.out.println(LocalDate.now().with(TemporalAdjusters.previous(DayOfWeek.SATURDAY)));<br>System.out.println(<span class="hljs-string">&quot;本月最后一个工作日&quot;</span>);<br>System.out.println(LocalDate.now().with(TemporalAdjusters.lastInMonth(DayOfWeek.FRIDAY)));<br></code></pre></td></tr></table></figure></li><li><p>直接使用lambda表达式进行自定义的时间调整。比如为当前时间增加100以内的随机天数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(LocalDate.now().with(temporal -&gt; temporal.plus(ThreadLocalRandom.current().nextInt(<span class="hljs-number">100</span>), ChronoUnit.DAYS)));<br></code></pre></td></tr></table></figure></li><li><p>判断日期是否符合某个条件。比如自定义函数，判断指定日期是否是家庭成员的生日</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Boolean <span class="hljs-title function_">isFamilyBirthday</span><span class="hljs-params">(TemporalAccessor date)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> date.get(ChronoField.MONTH_OF_YEAR);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">day</span> <span class="hljs-operator">=</span> date.get(ChronoField.DAY_OF_MONTH);<br>        <span class="hljs-keyword">if</span> (month == Month.FEBRUARY.getValue() &amp;&amp; day == <span class="hljs-number">17</span>) &#123;<br>            <span class="hljs-keyword">return</span> Boolean.TRUE;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (month == Month.SEPTEMBER.getValue() &amp;&amp; day == <span class="hljs-number">21</span>) &#123;<br>            <span class="hljs-keyword">return</span> Boolean.TRUE;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (month == Month.MARCH.getValue() &amp;&amp; day == <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">return</span> Boolean.TRUE;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Boolean.FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;查询是否今天要举办生日&quot;</span>);<br><span class="hljs-comment">// 2023/3/4</span><br>System.out.println(LocalDate.now().query(MySqlCall::isFamilyBirthday));<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">查询是否今天要举办生日<br>true<br></code></pre></td></tr></table></figure></li></ol><h3 id="Java8日期时间处理的坑"><a href="#Java8日期时间处理的坑" class="headerlink" title="Java8日期时间处理的坑"></a>Java8日期时间处理的坑</h3><p>在我们使用Java8的Period计算两个日期差的时候，我们通过Period.between 得到了两个 LocalDate 的差，返回的是两个日期差几年零几月零几天。如果希望得知两个日期之间差几天，直接调用 Period 的 getDays() 方法得到的只是最后的“零几天”，而不是算总的间隔天数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;计算日期差&quot;</span>);<br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">today</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2023</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">otherDay</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2023</span>, <span class="hljs-number">10</span>, <span class="hljs-number">28</span>);<br>System.out.println(Period.between(otherDay,today).getDays());<br>System.out.println(Period.between(otherDay,today));<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">计算日期差<br>-24<br>P-7M-24D<br></code></pre></td></tr></table></figure><p>那对于这类问题，我们怎么处理呢？我们可以通过<code>ChronoUnit.DAYS</code>解决这个问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(ChronoUnit.DAYS.between(otherDay,today));<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-<span class="hljs-number">238</span><br></code></pre></td></tr></table></figure><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>在我们刚开始接触Java8的时候，可能会有些人认为<code>Date</code>就是Java8的<code>LocalDateTime</code>。其实并不是的，确实他们都没有时区概念，但是<code>java.util.Date</code>类是因为使用UTC表示，所以没有时区概念，其本质是<strong>时间戳</strong>。而<code>LocalDateTime</code>严格来说是日期时间的一种表示，而不是一个时间点。</p><p>所以，我们可以发现，当我们需要将<code>Date</code>转换成<code>LocalDateTime</code>时，需要通过<code>Date</code>的<code>toInstant</code>方法得到一个UTC时间戳进行转换，并需要提供当前的时区，这样才能将UTC时间转换成本地日期时间。</p><p>反过来，如果要将<code>LocalDateTime</code>的时间表示转化成<code>Date</code>时，需要提供时区，用于指定哪个时区的时间表示，也就是先通过<code>atZone</code>方法把<code>LocalDateTime</code>转换成<code>ZoneDateTime</code>，然后才能获取UTC时间戳。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime</span> <span class="hljs-operator">=</span> LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());<br><span class="hljs-type">Date</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());<br>System.out.println(out);<br></code></pre></td></tr></table></figure><hr><p>我是Gcoder，一个热爱学习的Java跑马选手。</p>]]></content>
    
    
    <summary type="html">古往今来，Java的日期在Java8有何改变呢？</summary>
    
    
    
    <category term="技术" scheme="https://gcoder5.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="https://gcoder5.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>千回百转仍需坚守初心</title>
    <link href="https://gcoder5.com/2023/03/03/%E5%8D%83%E5%9B%9E%E7%99%BE%E8%BD%AC%E4%BB%8D%E9%9C%80%E5%9D%9A%E5%AE%88%E5%88%9D%E5%BF%83/"/>
    <id>https://gcoder5.com/2023/03/03/%E5%8D%83%E5%9B%9E%E7%99%BE%E8%BD%AC%E4%BB%8D%E9%9C%80%E5%9D%9A%E5%AE%88%E5%88%9D%E5%BF%83/</id>
    <published>2023-03-03T12:58:34.000Z</published>
    <updated>2023-03-03T14:14:11.324Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/%E5%8D%83%E5%9B%9E%E7%99%BE%E8%BD%AC%E4%BB%8D%E9%9C%80%E5%9D%9A%E5%AE%88%E5%88%9D%E5%BF%83/bird-7299650_960_720.jpg" alt="bird-7299650_960_720"></p><h3 id="一些想说的话"><a href="#一些想说的话" class="headerlink" title="一些想说的话"></a>一些想说的话</h3><p>人的惰性是越放肆越严重，距离上次的博客之旅一晃又过去了仨年。做人确实没有多少个三年可以浪费的，但是已逝年岁，不咎其责。生活本就是一次又一次的试错，一次又一次的探索，如果前进的方向错了，那停下来就是一种进步。</p><p>马上就要步入而立之年了，同时今年又完成了一件人生大事。迎来了自家的小公主，岁月好似春风一般，仿佛吹到了盛夏，又仿佛存在了一刹，从青葱到成熟，从人夫到人父，生命是一场奇妙之旅，但千回百转也仍需坚守初心。</p><p>每次的幡然醒悟，总会有一个生动的理由。上一次是一个深漂程序员在大城市的有感而发，想分享技术；而如今是一名新晋奶爸想在而立之年记录技术，把坚持和耐心教给我的小公主，做一个极佳的榜样。</p><h3 id="一些最近的感悟"><a href="#一些最近的感悟" class="headerlink" title="一些最近的感悟"></a>一些最近的感悟</h3><p>中年危机是真实存在的，在从事了五年多的开发之后，又遇到了形形色色的同行人或者同龄人。有的人因为资历和年限并不相符而被陷入困境；有的人或因固守成规或因锋芒毕露而寸步难行；也有的人资历尚浅但博学多才；更有甚者而立之年已一身荣耀。从前说，落后就要挨打，诚然这句话也适用于当今的IT圈。技术的日新月异，如同大浪淘沙般不断冲击，能够屹立不倒的人凤毛麟角，而这批人无一不是拥有不断保持学习，不断深入学习的良好品质。</p><p>初心是选择每一条道路的果决与勇敢，还有义无反顾。每条路都会有荆棘和诱惑，不忘初心者善，坚守初心者大善。兜兜转转，我们会在人生的道路上反复徘徊，有时候是不坚定，有时候是不断论证。终其一生，我们会不断完整自己的人生观和价值观。愿有一天，我们皆能得偿所愿。</p><h3 id="一些写在最后的祝福"><a href="#一些写在最后的祝福" class="headerlink" title="一些写在最后的祝福"></a>一些写在最后的祝福</h3><p>最后，兔年是个健康的开端，也是博客重新开始的时候，谨以此文祝福各位平安喜乐！</p>]]></content>
    
    
    <summary type="html">不忘初心方能无悔此行！</summary>
    
    
    
    <category term="杂谈" scheme="https://gcoder5.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="生活" scheme="https://gcoder5.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
