<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java中的内存泄漏和内存溢出（上）</title>
    <link href="/2023/03/04/Java%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/2023/03/04/Java%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>今天我们的目的很纯粹，就是来讲一下内存泄漏（<strong>memory leak</strong>）和内存溢出（<strong>out of memory</strong>）。很多时候，我们会听到这两个名词，但是系统的全面的了解却不多，所以今天我们就一起来学习学习。</p><h3 id="JVM如何判断对象是否健在"><a href="#JVM如何判断对象是否健在" class="headerlink" title="JVM如何判断对象是否健在"></a>JVM如何判断对象是否健在</h3><p>在讲内存之前呢，我们首先要知道这么一个问题：JVM是如何知道某个对象是否还健在的呢？我们都知道Java对象主要是存放在Java堆里的，所以当我们的GC（垃圾收集器）在对Java堆进行回收前，需要先确定这些对象是否还“存活”，哪些已经“死去”（不再被引用）。</p><p>下面我们就来讲几种用来判断对象是否健在的算法</p><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p><strong>对象中添加一个引用计数器，每有一个地方引用它时，计数器值就加一；当引用失效是，计数器值就减一；任何时刻计数器为零的对象就是不可以能再被使用的对象</strong>。</p><p>该算法的原理简单，判定效率高，但是我们目前主流的JVM并没有选用此算法来管理内存，主要是因为使用该算法时，需要配合大量的额外处理才能确保正确的工作，例如要解决<strong>对象之间的相互循环引用</strong>的问题，我们可以通过下面的代码例子来解答为啥不用的疑惑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MyTest</span> <span class="hljs-variable">myTest1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTest</span>();<br>        <span class="hljs-type">MyTest</span> <span class="hljs-variable">myTest2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTest</span>();<br><br>        myTest1.myTest = myTest2;<br>        myTest2.myTest = myTest1;<br><br>        myTest1 = <span class="hljs-literal">null</span>;<br>        myTest2 = <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-comment">// 假设在这行发生GC，test1和test2是否能被回收？</span><br>        System.gc();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">MyTest</span> <span class="hljs-variable">myTest</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析代码，myTest1和myTest2对象都被设置成了null，在后面发生GC的时候，如果按照引用计数算法，这两个对象虽然都被设置成了null，但是<strong>myTest1引用了myTest2，myTest2又引用了myTest1，所以这两个对象的引用计数值都不为0，所以都不会被回收</strong>，但是真正的实际运行结果是，这两个对象都被回收了，这也说明HotSpot虚拟机并不是用引用计数法来进行的内存管理。</p><p>那JVM用的是什么算法吗？我们继续往下看…</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>这个算法的基本思路就是通过一一系列称为<code>GC Roots</code> 的根对象作为起始节点集，从这些节点开始根据引用关系向下搜索，搜索走过的的路径称为“<strong>引用链</strong>”（Reference Chain）,如果某个对象到<code>GC Roots </code>间没有任何引用链相连，或者从<code>GC Roots</code> 到这个对象不可达时，则证明此对象是不可能再被使用的。</p><p><span style="color:blue"><strong>当前主流的商用程序语言（Java、C#等），都是通过可达性分析（Reachability Analysis）算法来判断对象是否存活的。</strong></span></p><p>我们可以来看下下面的图，<strong>虽然object10、object11、object12互相有关联，但是它们到GC Roots是不可达的，因此它们会被判定为可回收的对象。</strong></p><p><img src="/Java%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%88%E4%B8%8A%EF%BC%89/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png" alt="可达性分析算法"></p><p>在Java程序中，固定可作为GC Roots 的对象包括以下几种：</p><ol><li><p>虚拟机栈中引用的对象</p><p>比如：各个线程被调用的方法中使用到的参数、局部变量等。</p></li><li><p>本地方法栈内JNI（通常说的本地方法）引用的对象</p></li><li><p>方法区中类静态属性引用的对象</p><p>比如：Java类的引用类型静态变量</p></li><li><p>方法区中常量引用的对象</p><p>比如：字符串常量池（string Table） 里的引用</p></li><li><p>所有被同步锁synchronized持有的对象</p></li><li><p>Java虚拟机内部的引用</p><p>比如：基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError） ，系统类加载器。</p></li><li><p>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</p></li><li><p>除了这些固定的GCRoots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。</p><p>比如：分代收集和局部回收（Partial GC）</p></li></ol><p>通过对上面两种算法的介绍，实际上在我们判断一个对象是否存在的依据，离不开这个对象是否被<strong>引用</strong>离不开关系。</p><p>在JDK1.2之前，Java对引用的概念是：如果reference类型的数据中存储的数值代表的是另外一块儿内存的地址，就称该reference数据是代表某块内存、某个对象的引用</p><p>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为<code>强引用（Strongly Reference）</code>、<code>软引用（Soft Reference）</code>、<code>弱引用（Weak Reference）</code>、<code>虚引用（Phantom Reference）</code>4种，*<em>这4种引用强度依次逐渐减弱</em></p><p>对于这四种不同的引用方式，我们做一个基本的介绍：</p><p><img src="/Java%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%88%E4%B8%8A%EF%BC%89/%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.png" alt="引用类型"></p><ol><li><p><strong>强引用</strong>是传统“引用”的定义，指引用复制，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><p>这种引用关系。无论在任何情况下，<strong>只要强引用关系还存在，垃圾收集器就不会回收掉被引用的对象</strong>。</p></li><li><p><strong>软引用</strong>是用来描述一些还有用，但非必须的对象。在系统发生内存溢出前，会先对软引用对象进行第二次回收，如果回收后还没有足够的内存，才会抛出内存溢出的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-type">ReferenceQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>();<br><span class="hljs-type">SoftReference</span> <span class="hljs-variable">reference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>(obj, queue);<br><span class="hljs-comment">// 强引用对象滞空，保留软引用</span><br>obj = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>弱引用</strong>也是用来描述那些非必须的对象，但是它的强度比软引用更弱一些，弱引用的对象，只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p><p>而<strong>弱引用和软引用的区别</strong>在于：弱引用的对象拥有更短的生命周期，只要垃圾回收器扫描到它，不管内存空间充足与否，都会回收它的内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-type">ReferenceQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>();<br><span class="hljs-type">WeakReference</span> <span class="hljs-variable">reference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>(obj, queue);<br><span class="hljs-comment">//强引用对象滞空，保留软引用</span><br>obj = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>虚引用</strong>也称为“幽灵引用”或“幻影引用”，它是最弱的一种引用关系。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</p></li></ol><p>综上来理解的话，通过定义四种引用类型以及可达性分析算法来判断对象是否健在。但是，是不是被可达性分析算法判断为不可达对象就“非死不可”了，实际上，要真正回收一个对象，是需要至少经历两次标记过程：</p><ol><li>如果第一次对象在进行可达性分析后发现与GC Roots 不可达，将进行第一次标记。</li><li>随后对此对象进行一次是否有必要执行<code>finalize()</code>方法进行筛选，假如对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机调用过，都视为“没有必要执行”。</li></ol><blockquote><p>如果对象被判定有必要执行finalize()方法，会将对象放置在一个名为F-Queue的队列中，并在由一条由虚拟机自动建立的、低调度的线程区执行它们的finalize()方法。但并不承诺一定会等待它们运行结束。</p></blockquote><p><span style="color:red"><strong>注意事项：</strong></span>任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临第二次回收，它的finalize()方法不会被再次执行。<br><strong>还有一点就是Java官方已经明确声明不推荐手动调用finalize()方法了，因为它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，并且finanlize()能做的所有工作，使用try-finally或其他方式都可以做的更好、更及时。</strong></p><h3 id="什么是内存泄漏（memory-leak）"><a href="#什么是内存泄漏（memory-leak）" class="headerlink" title="什么是内存泄漏（memory leak）"></a>什么是内存泄漏（memory leak）</h3><p>学习完了上面的对象回收之后，我们接下来就讲一下什么是内存泄漏。</p><p>在用可达性分析算法判断对象是否是不再使用的对象时，本质都是判断一个对象是否还被引用。那么对于这种情况下，由于代码的实现不同就会出现很多内存泄漏问题（让JVM误以为此对象还在引用中，无法回收，造成内存泄漏）。</p><p>主要关注两点：</p><ol><li>是否还被使用？是</li><li>是否还被需要？否</li></ol><h3 id="内存泄漏（memory-leak）的理解"><a href="#内存泄漏（memory-leak）的理解" class="headerlink" title="内存泄漏（memory leak）的理解"></a>内存泄漏（memory leak）的理解</h3><p>严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。但实际情况很多时候一些不太好的实践（或疏忽）才导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。</p><h3 id="内存泄漏和内存溢出的关系"><a href="#内存泄漏和内存溢出的关系" class="headerlink" title="内存泄漏和内存溢出的关系"></a>内存泄漏和内存溢出的关系</h3><p>内存泄漏（memory leak）就是<strong>占着茅坑不拉屎</strong>，明明申请了内存并使用完了但是就是不释放掉。比如一共有1024M的内存，分配了512M的内存一直不回收，那么可用的内存就只有512M了，仿佛漏掉了一部分。</p><p>内存溢出（out of memory）就是申请内存的时候，没有足够的内存可以使用。通俗一点儿讲，一个厕所就三个坑，有两个站着茅坑不走的（内存泄漏），剩下最后一个坑，厕所表示接待压力很大，这时候一下子来了两个人，坑位（内存）就不够了，内存泄漏变成了内存溢出了。</p><p>所以，内存泄漏的增多，最终会导致内存溢出。</p><h3 id="内存泄漏的分类"><a href="#内存泄漏的分类" class="headerlink" title="内存泄漏的分类"></a>内存泄漏的分类</h3><ol><li>经常发生：发生内存泄漏的代码会被多次执行，每次执行，泄漏一块内存；</li><li>偶然发生：在某些特定情况下才会发生；</li><li>一次性：发生内存泄漏的方法只会执行一次；</li><li>隐式泄漏：一直占着内存不释放，直到执行结束；严格的说这个不算内存泄漏，因为最终释放掉了。</li></ol><h3 id="常见的内存泄漏8种情况"><a href="#常见的内存泄漏8种情况" class="headerlink" title="常见的内存泄漏8种情况"></a>常见的内存泄漏8种情况</h3><h4 id="1-静态集合类"><a href="#1-静态集合类" class="headerlink" title="1.静态集合类"></a>1.静态集合类</h4><p>静态集合类，如HashMap、LinkedList等等。<strong>如果这些容器为静态的，那么它们的声明周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏</strong>。简单而言，长生命周期的对象有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryLeak</span> &#123;<br>   <span class="hljs-keyword">static</span> <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">oomTests</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">// 局部变量</span><br>       list.add(obj);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-各种连接使用后未关闭"><a href="#2-各种连接使用后未关闭" class="headerlink" title="2.各种连接使用后未关闭"></a>2.<strong>各种连接使用后未关闭</strong></h4><p>如数据库连接、网络 http 连接、io 连接等等。当程序操作数据库时，首先应该建立数据库的连接 Connection，操作语句时建立 Statement 对象，获取结果集建立 ResultSet 对象，之后需要显示的调用 close 方法来关闭连接，只有关闭连接后，GC 才会对对应的未使用对象进行回收。<strong>没有及时的关闭数据库连接，会导致大量对象长期占用内存空间，导致内存泄漏</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>   <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-变量的作用域不合理"><a href="#3-变量的作用域不合理" class="headerlink" title="3.变量的作用域不合理"></a>3.<strong>变量的作用域不合理</strong></h4><p>如本该唯一定义在某方法的变量定义在了全局变量。一般来讲，<strong>一个变量的作用范围大于其所被使用的范围，可能发生内存泄漏</strong>，表现在存在时间大于使用时间，即使用完了但是还不能被回收，就比如下面的列子。另外，如果没有及时的将未使用的对象置 null，也有可能导致内存泄漏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.gcoder.common.core;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存泄漏例子</span><br><span class="hljs-comment"> * 这里的变量 info 在方法 receiveAndSaveInfo 中进行赋值和保存，在该方法执行完毕后本应该被 GC 回收，</span><br><span class="hljs-comment"> * 但由于全局变量的生命周期是跟随对象的，所有当方法执行完不能被回收，可能造成内存泄漏。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> gcoder</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoMemoryLeak</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 消息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String info;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveAndSaveInfo</span><span class="hljs-params">()</span> &#123;<br>        <br>        <span class="hljs-comment">// 模拟接受消息</span><br>        receiveInfo();<br>        <br>        <span class="hljs-comment">// 模拟存储消息</span><br>        saveInfo();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-内部类持有外部类"><a href="#4-内部类持有外部类" class="headerlink" title="4.内部类持有外部类"></a>4.<strong>内部类持有外部类</strong></h4><p>如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。</p><h4 id="5-改变哈希值"><a href="#5-改变哈希值" class="headerlink" title="5.改变哈希值"></a>5.改变哈希值</h4><p>当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希值就不同了，在这种情况下，即使在 contains 方法使用该对象的当前引用作为的参数去 HashSet 集合中检索对象，也将返回找不到对象的结果，这也会导致无法从 HashSet 集合中单独删除当前对象，造成内存泄露。</p><h4 id="6-栈引起的内存泄漏"><a href="#6-栈引起的内存泄漏" class="headerlink" title="6.栈引起的内存泄漏"></a>6.<strong>栈引起的内存泄漏</strong></h4><p>我们可以编辑一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoMemoryLeak</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">private</span> Object[] elements;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoMemoryLeak</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.elements = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[DEFAULT_INITIAL_CAPACITY];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 进栈</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o o</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> gaohuiwu</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@date</span> 2023-03-05</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(Object o)</span> &#123;<br>        ensureCapacity();<br>        elements[size++] = o;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 出栈</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> lang.Object</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> gaohuiwu</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@date</span> 2023-03-05</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmptyStackException</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> elements[--size];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 扩容</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> gaohuiwu</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@date</span> 2023-03-05</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (elements.length == size) &#123;<br>            elements = Arrays.copyOf(elements, size * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段模拟栈操作的代码存在隐蔽的内存泄漏问题。定位到pop()函数，在return语句中，当我们弹出一个元素时，只是简单的让栈顶指针（size）-1。逻辑上，栈中的这个元素已经弹出，已经没有用了。但是事实上，<strong>被弹出的元素依然存在于elements数组中</strong>，它依然被elements数组所引用，GC是无法回收被引用着的对象的。也许你期望等这整个栈失去引用（将被GC回收时），栈内的elements数组一起被GC回收。但是实际的使用过程中，又有谁能够预料到这个栈会存活多长时间。为了保险起见，我们需要在弹出一个元素的时候，就让这个元素失去引用，便于GC回收。我们只需要让Pop()函数弹出时，同时解除对弹出元素的引用即可。</p><h4 id="7-缓存泄漏"><a href="#7-缓存泄漏" class="headerlink" title="7.缓存泄漏"></a>7.缓存泄漏</h4><p>内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘，对于这个问题，可以使用<code>WeakHashMap</code>代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值。</p><h4 id="8-监听器和回调"><a href="#8-监听器和回调" class="headerlink" title="8.监听器和回调"></a>8.监听器和回调</h4><p>内存泄漏第三个常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显示的取消，那么就会积聚。需要确保回调立即被当作垃圾回收的最佳方法是只保存他的若引用，例如将他们保存成为WeakHashMap中的键。</p><h3 id="预防内存泄漏的方法"><a href="#预防内存泄漏的方法" class="headerlink" title="预防内存泄漏的方法"></a>预防内存泄漏的方法</h3><ol><li>尽量减少使用静态变量，或者使用完及时赋值为 null</li><li>明确内存对象的有效作用域，<strong>尽量缩小对象的作用域</strong>，能用局部变量处理的不用成员变量，因为局部变量弹栈会自动回收</li><li>减少长生命周期的对象持有短生命周期的引用</li><li>使用 <code>StringBuilder</code> 和<code>StringBuffer</code>进行字符串连接，<code>Sting</code> 和<code> StringBuilder</code> 以及 <code>StringBuffer </code>等都可以代表字符串，其中 <code>String </code>字符串代表的是不可变的字符串，后两者表示可变的字符串。如果使用多个<code>String</code>对象进行字符串连接运算，在运行时可能产生大量临时字符串，这些字符串会保存在内存中从而导致程序性能下降</li><li>对于不需要使用的对象手动设置 null 值，不管 GC 何时会开始清理，我们都<strong>应及时的将无用的对象标记为可被清理的对象</strong></li><li>各种连接（数据库连接，网络连接，IO连接）操作，务必显示调用close关闭</li></ol><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>本文我们一起学习了jvm的回收机制和内存泄漏的一些场景和预防措施，那么下个篇幅，我们就来讲讲所谓的内存溢出～</p><hr><p>我是Gcoder，一个热爱学习的Java跑马选手。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认识下Java8的日期时间类</title>
    <link href="/2023/03/03/%E8%AE%A4%E8%AF%86%E4%B8%8BJava8%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B1%BB/"/>
    <url>/2023/03/03/%E8%AE%A4%E8%AF%86%E4%B8%8BJava8%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p>技术是无止境的，这些年搁置了博客。但没忘记学习，这段时间先把之前的笔记更新出来，此后我们再一道来谈谈近些年的一些新玩意儿！</p></blockquote><h3 id="从Date类开始讲起"><a href="#从Date类开始讲起" class="headerlink" title="从Date类开始讲起"></a>从Date类开始讲起</h3><p>Date这个类，我们应该都不陌生，因为我们经常用<code>new Date()</code>来获取当前的时间。而对于Date类来说呢，我们需要有这么两个认知。</p><ol><li><p>Date不存在时区的问题，也就是说<strong>世界上的任何一台计算机编写<code>new Date()</code>执行之后得到的都是同样的时间</strong>。</p><p>原因我也解释一下，因为Date中保存的是<code>UTC</code>时间，<code>UTC</code>时间是以原子钟为基础的统一时间，不以时间参照计时，所以不存在时区的划分。</p></li><li><p>Date中保存的是一个时间戳，代表的是从1970年1月1日0点（Epoch时间）到现在的毫秒数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">0</span>));<br>System.out.println(TimeZone.getDefault().getID() + <span class="hljs-string">&quot;:&quot;</span> + TimeZone.getDefault().getRawOffset()/<span class="hljs-number">3600000</span>);<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">输出内容</span><br>Thu Jan 01 08:00:00 CST 1970<br>Asia/Shanghai:8<br></code></pre></td></tr></table></figure></li></ol><h3 id="日期时间该怎么保存呢"><a href="#日期时间该怎么保存呢" class="headerlink" title="日期时间该怎么保存呢"></a>日期时间该怎么保存呢</h3><p>因为有时区的影响，所以对于不同的日期形式有不同的方式来进行保存。</p><ol><li><p>以UTC保存，保存的时间没有时区属性，是不涉及时区时间差问题的世界统一时间。<strong>时间戳</strong>或Java中的<strong>Date类</strong>就是这种方式，也是推荐的方式。</p></li><li><p>以字符串的形式保存，比如年&#x2F;月&#x2F;日 时:分:秒，一定要同时<strong>保存时区信息</strong>。</p><p>有时区信息，才能知道这个字符串时间真正的时间点。Calendar 是有时区概念的，所以我们通过不同的时区初始化 Calendar，得到了不同的时间。</p></li></ol><h3 id="关于字符串和Date的相互转换"><a href="#关于字符串和Date的相互转换" class="headerlink" title="关于字符串和Date的相互转换"></a>关于字符串和Date的相互转换</h3><ol><li><p>对于同一个时间表示，比如2023-03-03 22:00:00，不同时区的人转换成Date会得到不同的时间（时间戳）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">stringDate</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2023-03-03 22:00:00&quot;</span>;<br><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">inputFormat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><span class="hljs-comment">// 默认时区解析时间表示</span><br><span class="hljs-type">Date</span> <span class="hljs-variable">date1</span> <span class="hljs-operator">=</span> inputFormat.parse(stringDate);<br>System.out.println(date1 + <span class="hljs-string">&quot;:&quot;</span> + date1.getTime());<br><span class="hljs-comment">// 纽约时区解析时间表示</span><br>inputFormat.setTimeZone(TimeZone.getTimeZone(<span class="hljs-string">&quot;Asia/Shanghai&quot;</span>));<br><span class="hljs-type">Date</span> <span class="hljs-variable">date2</span> <span class="hljs-operator">=</span> inputFormat.parse(stringDate);<br>System.out.println(date2 + <span class="hljs-string">&quot;:&quot;</span> + date2.getTime());<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">输出内容</span><br>Fri Mar 03 22:00:00 CST 2023:1677852000000<br>Fri Mar 03 22:00:00 CST 2023:1677852000000<br></code></pre></td></tr></table></figure></li><li><p>不同时区下格式化得到的不同的时间表示，比如当前时区和纽约时区的时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">stringDate</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2023-03-03 22:00:00&quot;</span>;<br><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">inputFormat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><span class="hljs-type">Date</span> <span class="hljs-variable">date1</span> <span class="hljs-operator">=</span> inputFormat.parse(stringDate);<br><span class="hljs-type">String</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;[yyyy-MM-dd HH:mm:ss Z]&quot;</span>).format(date1);<br>System.out.println( format);<br>TimeZone.setDefault(TimeZone.getTimeZone(<span class="hljs-string">&quot;America/New_York&quot;</span>));<br><span class="hljs-type">String</span> <span class="hljs-variable">format1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;[yyyy-MM-dd HH:mm:ss Z]&quot;</span>).format(date1);<br>System.out.println(format1);<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[2023-03-03 22:00:00 +0800]<br>[2023-03-03 09:00:00 -0500]<br></code></pre></td></tr></table></figure><p><span style="color:red"><strong>注意事项：</strong></span>有时候数据库相同的时间，由于<strong>服务器的时区</strong>设置不同，读取到的时间表示不同。这正是时区发挥作用了，因为UTC时间需要根据当前时区解析正确的本地时间。</p></li></ol><h3 id="Java8的时间日期类"><a href="#Java8的时间日期类" class="headerlink" title="Java8的时间日期类"></a>Java8的时间日期类</h3><p>对于Java8而言，Java8对于日期的处理发生了巨大的改变，以下我们就一起来学习一下。</p><ol><li><p>初始化时区的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化标准的时区</span><br>ZoneId.of(<span class="hljs-string">&quot;Asia/Shanghai&quot;</span>);<br><span class="hljs-comment">// 初始化一个具有指定时间差的自定义时区</span><br>ZoneOffset.ofHour()<br></code></pre></td></tr></table></figure></li><li><p><code>LocalDateTime</code>不带有时区属性，所以它只是一个时间表示，命名为本地时区的日期时间；ZonedDateTime&#x3D;LocalDateTime+ZoneId，具有时区性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> ZonedDateTime.of(LocalDateTime.parse(stringDate, dateTimeFormatter), timeZoneJST);<span class="hljs-comment">//使用DateTimeFormatter格式化时间，可以通过withZone方法直接设置格式化使用的时区DateTimeFormatter outputFormat = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss Z&quot;);System.out.println(timeZoneSH.getId() + outputFormat.withZone(timeZoneSH).format(date));System.out.println(timeZoneNY.getId() + outputFormat.withZone(timeZoneNY).format(date));System.out.println(timeZoneJST.getId() + outputFormat.withZone(timeZoneJST).format(date));</span><br></code></pre></td></tr></table></figure></li><li><p>使用<code>DateTimeFormatter</code>格式化时间的时候，可以直接通过withZone方法直接设置格式化使用的时区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(timeZoneJST.getId() + outputFormat.withZone(timeZoneJST).format(date));<br></code></pre></td></tr></table></figure><p><span style="color:red"><strong>注意事项：</strong></span>要正确处理国际化时间问题，使用Java8的日期时间类，即使用ZonedDateTime保存时间，然后使用设置了ZoneId的DateTimeFormatter配合ZonedDateTime进行时间格式化得到本地时间表示。</p></li></ol><h3 id="不建议继续使用SimpleDateFormat"><a href="#不建议继续使用SimpleDateFormat" class="headerlink" title="不建议继续使用SimpleDateFormat"></a>不建议继续使用<code>SimpleDateFormat</code></h3><h4 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h4><p>在我们对于日期进行格式化的时候，在Java8之前我们经常用使用<code>SimpleDateFormat</code>来进行格式化，实际上<code>SimpleDateFormat</code>是线程不安全的，所以并不推荐使用。</p><p>我们可以通过源码来解读下为啥<code>SimpleDateFormat</code>是线程不安全的。首先，我们目光聚焦到官网的一段话：</p><blockquote><p>Synchronization<br>Date formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally.</p></blockquote><p>大致意思就是说：这个玩意儿线程不安全，如果要用在多线程，最好是每个线程有各自的<code>SimpleDateFormat</code>对象；如果在并发环境下使用SimpleDateFormat对象，需要进行同步串行。</p><p>下面，我们一起来看下源码，正常情况，我们使用<code>parse()</code>和<code>format()</code>两个函数比较多，所以我们那就来看看关于这两个函数的实现</p><p><code>SimpleDateFormat</code>的<code>parse()</code>局部源码</p><p><img src="https://p.ipic.vip/gkxat4.png" alt="image-20230304000439390"></p><p><code>SimpleDateFormat</code>的<code>format()</code>局部源码</p><p><img src="https://p.ipic.vip/w5aa4n.png" alt="image-20230304000547953"></p><p>从上面的两个函数的局部代码，我们可以看到两函数有共用一个成员变量<code>calendar</code>，那么这个变量是怎么定义的呢？实际上，它是父类<code>DateFormat</code>的一个普通的成员变量。</p><p><img src="https://p.ipic.vip/28kh4z.png" alt="image-20230304000741733"></p><p>综上，parse与format方法，是共用一个calendar成员变量的，所以如果多线程共用SimpleDateFormat对象，即使A线程做format操作，B线程做parse操作，也会存在并发问题，所以它是线程不安全的。</p><p>假如我们真的需要使用到<code>SimpleDateFormat</code>，那我们可以定义一个线程变量来解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; threadSafeSimpleDateFormat = ThreadLocal.withInitial(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));<br></code></pre></td></tr></table></figure><h4 id="转换太宽容"><a href="#转换太宽容" class="headerlink" title="转换太宽容"></a>转换太宽容</h4><p>为什么说<code>SimpleDateFormat</code>转换太宽容，那是因为尽管需要解析的字符串和<code>SimpleDateFormat</code>指定的格式不匹配，但是其进行转换后还是能够得到结果，这样会导致我们在业务处理上，获取到错误的结果，从而引发难以定位的业务异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 例：用yyyyMM来解析20230303字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">dateString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;20230303&quot;</span>;<br><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">dateFormat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyyMM&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;result:&quot;</span> + dateFormat.parse(dateString));<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">原因是把0303当成了月份，相当于25年(303/12)</span><br>result:Sun Mar 01 00:00:00 CST 2048<br></code></pre></td></tr></table></figure><h3 id="Java8是如何规避SimleDateFormat的坑"><a href="#Java8是如何规避SimleDateFormat的坑" class="headerlink" title="Java8是如何规避SimleDateFormat的坑"></a>Java8是如何规避SimleDateFormat的坑</h3><p>Java8对日期进行格式化是用的<code>DateTimeFormatter</code>这个类来处理，而这个类也规避了<code>SimleDateFormat</code>带来的问题。</p><ol><li><p>使用 <code>DateTimeFormatterBuilder</code> 来定义格式化字符串，不用去记忆使用大写的 Y 还是小写的 Y，大写的 M 还是小写的 m</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dateTimeFormatter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DateTimeFormatterBuilder</span>()<br>        .appendValue(ChronoField.YEAR) <span class="hljs-comment">//年</span><br>        .appendLiteral(<span class="hljs-string">&quot;/&quot;</span>)<br>        .appendValue(ChronoField.MONTH_OF_YEAR) <span class="hljs-comment">//月</span><br>        .appendLiteral(<span class="hljs-string">&quot;/&quot;</span>)<br>        .appendValue(ChronoField.DAY_OF_MONTH) <span class="hljs-comment">//日</span><br>        .appendLiteral(<span class="hljs-string">&quot; &quot;</span>)<br>        .appendValue(ChronoField.HOUR_OF_DAY) <span class="hljs-comment">//时</span><br>        .appendLiteral(<span class="hljs-string">&quot;:&quot;</span>)<br>        .appendValue(ChronoField.MINUTE_OF_HOUR) <span class="hljs-comment">//分</span><br>        .appendLiteral(<span class="hljs-string">&quot;:&quot;</span>)<br>        .appendValue(ChronoField.SECOND_OF_MINUTE) <span class="hljs-comment">//秒</span><br>        .appendLiteral(<span class="hljs-string">&quot;.&quot;</span>)<br>        .appendValue(ChronoField.MILLI_OF_SECOND) <span class="hljs-comment">//毫秒</span><br>        .toFormatter();<br></code></pre></td></tr></table></figure></li><li><p>DateTimeFormatter 是线程安全的，可以定义为 static 使用</p></li><li><p>DateTimeFormatter 的解析比较严格，需要解析的字符串和格式不匹配时，会直接报错，而不会把 0303 解析为月份</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用刚才定义的DateTimeFormatterBuilder构建的DateTimeFormatter来解析这个时间</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime</span> <span class="hljs-operator">=</span> LocalDateTime.parse(<span class="hljs-string">&quot;2023/3/3 12:00:00.789&quot;</span>, dateTimeFormatter);<br><span class="hljs-comment">// 解析成功</span><br>System.out.println(localDateTime.format(dateTimeFormatter));<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">2023/3/3 12:0:0.789<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用yyyyMM格式解析20230303是否可以成功呢？</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">dt</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;20230303&quot;</span>;<br>        <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dateTimeFormatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyyMM&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;result:&quot;</span> + dateTimeFormatter.parse(dt));<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">Exception in thread &quot;main&quot; java.time.format.DateTimeParseException: Text &#x27;20230303&#x27; could not be parsed at index 0<br>at java.time.format.DateTimeFormatter.parseResolved0(DateTimeFormatter.java:1949)<br>at java.time.format.DateTimeFormatter.parse(DateTimeFormatter.java:1777)<br>at com.tansun.MySqlCall.main(MySqlCall.java:121)<br></code></pre></td></tr></table></figure></li></ol><h3 id="Java8日期时间的计算"><a href="#Java8日期时间的计算" class="headerlink" title="Java8日期时间的计算"></a>Java8日期时间的计算</h3><p>通常我们在日常开发中会需要对时间进行计算，比如算一下今天起之后30天的时间，一般而言，我们会直接把Date().getTime 方法得到的时间戳加 30 天对应的毫秒数，也就是 30 天 *1000 毫秒 *3600 秒 *24 小时。但是这样就导致时间计算的错误，因为int会溢出，所以我们需要将30修正为30L。</p><p>在Java8之前，我们要进行日期时间计算的话，更推荐用<code>Calendar</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calendar</span> <span class="hljs-variable">calendar</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>calendar.setTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>calendar.add(Calendar.DAY_OF_MONTH,<span class="hljs-number">30</span>);<br>System.out.println(calendar.getTime());<br></code></pre></td></tr></table></figure><p>接下来，我们就来说说Java8对日期时间的计算操作</p><ol><li><p>使用各种<code>minus</code>和<code>plus</code>方法直接对日期进行加减操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// minus-减  plus-加</span><br>System.out.println(<span class="hljs-string">&quot;测试操作日期&quot;</span>);<br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">localDate</span> <span class="hljs-operator">=</span> LocalDate.now()<br>     .minus(Period.ofDays(<span class="hljs-number">1</span>))<br>     .plus(<span class="hljs-number">12</span>, ChronoUnit.DAYS)<br>     .minusMonths(<span class="hljs-number">1</span>)<br>     .plus(Period.ofMonths(<span class="hljs-number">1</span>));<br>System.out.println(<span class="hljs-string">&quot;localDate = &quot;</span> + localDate);<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">测试操作日期<br>localDate = 2023-03-15<br></code></pre></td></tr></table></figure></li><li><p>通过<code>with</code>方法进行快捷时间调节</p><ol><li>使用 TemporalAdjusters.firstDayOfMonth 得到当前月的第一天；</li><li>使用 TemporalAdjusters.firstDayOfYear() 得到当前年的第一天；</li><li>使用 TemporalAdjusters.previous(DayOfWeek.SATURDAY) 得到上一个周六；</li><li>使用 TemporalAdjusters.lastInMonth(DayOfWeek.FRIDAY) 得到本月最后一个周五。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;本月的第一天&quot;</span>);<br>System.out.println(LocalDate.now().with(TemporalAdjusters.firstDayOfMonth()));<br>System.out.println(<span class="hljs-string">&quot;今年的程序员日&quot;</span>);<br>System.out.println(LocalDate.now().with(TemporalAdjusters.firstDayOfYear()).plusDays(<span class="hljs-number">357</span>));<br>System.out.println(<span class="hljs-string">&quot;今天之前的一个周六&quot;</span>);<br>System.out.println(LocalDate.now().with(TemporalAdjusters.previous(DayOfWeek.SATURDAY)));<br>System.out.println(<span class="hljs-string">&quot;本月最后一个工作日&quot;</span>);<br>System.out.println(LocalDate.now().with(TemporalAdjusters.lastInMonth(DayOfWeek.FRIDAY)));<br></code></pre></td></tr></table></figure></li><li><p>直接使用lambda表达式进行自定义的时间调整。比如为当前时间增加100以内的随机天数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(LocalDate.now().with(temporal -&gt; temporal.plus(ThreadLocalRandom.current().nextInt(<span class="hljs-number">100</span>), ChronoUnit.DAYS)));<br></code></pre></td></tr></table></figure></li><li><p>判断日期是否符合某个条件。比如自定义函数，判断指定日期是否是家庭成员的生日</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Boolean <span class="hljs-title function_">isFamilyBirthday</span><span class="hljs-params">(TemporalAccessor date)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> date.get(ChronoField.MONTH_OF_YEAR);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">day</span> <span class="hljs-operator">=</span> date.get(ChronoField.DAY_OF_MONTH);<br>        <span class="hljs-keyword">if</span> (month == Month.FEBRUARY.getValue() &amp;&amp; day == <span class="hljs-number">17</span>) &#123;<br>            <span class="hljs-keyword">return</span> Boolean.TRUE;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (month == Month.SEPTEMBER.getValue() &amp;&amp; day == <span class="hljs-number">21</span>) &#123;<br>            <span class="hljs-keyword">return</span> Boolean.TRUE;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (month == Month.MARCH.getValue() &amp;&amp; day == <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">return</span> Boolean.TRUE;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Boolean.FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;查询是否今天要举办生日&quot;</span>);<br><span class="hljs-comment">// 2023/3/4</span><br>System.out.println(LocalDate.now().query(MySqlCall::isFamilyBirthday));<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">查询是否今天要举办生日<br>true<br></code></pre></td></tr></table></figure></li></ol><h3 id="Java8日期时间处理的坑"><a href="#Java8日期时间处理的坑" class="headerlink" title="Java8日期时间处理的坑"></a>Java8日期时间处理的坑</h3><p>在我们使用Java8的Period计算两个日期差的时候，我们通过Period.between 得到了两个 LocalDate 的差，返回的是两个日期差几年零几月零几天。如果希望得知两个日期之间差几天，直接调用 Period 的 getDays() 方法得到的只是最后的“零几天”，而不是算总的间隔天数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;计算日期差&quot;</span>);<br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">today</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2023</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">otherDay</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2023</span>, <span class="hljs-number">10</span>, <span class="hljs-number">28</span>);<br>System.out.println(Period.between(otherDay,today).getDays());<br>System.out.println(Period.between(otherDay,today));<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">计算日期差<br>-24<br>P-7M-24D<br></code></pre></td></tr></table></figure><p>那对于这类问题，我们怎么处理呢？我们可以通过<code>ChronoUnit.DAYS</code>解决这个问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(ChronoUnit.DAYS.between(otherDay,today));<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-<span class="hljs-number">238</span><br></code></pre></td></tr></table></figure><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>在我们刚开始接触Java8的时候，可能会有些人认为<code>Date</code>就是Java8的<code>LocalDateTime</code>。其实并不是的，确实他们都没有时区概念，但是<code>java.util.Date</code>类是因为使用UTC表示，所以没有时区概念，其本质是<strong>时间戳</strong>。而<code>LocalDateTime</code>严格来说是日期时间的一种表示，而不是一个时间点。</p><p>所以，我们可以发现，当我们需要将<code>Date</code>转换成<code>LocalDateTime</code>时，需要通过<code>Date</code>的<code>toInstant</code>方法得到一个UTC时间戳进行转换，并需要提供当前的时区，这样才能将UTC时间转换成本地日期时间。</p><p>反过来，如果要将<code>LocalDateTime</code>的时间表示转化成<code>Date</code>时，需要提供时区，用于指定哪个时区的时间表示，也就是先通过<code>atZone</code>方法把<code>LocalDateTime</code>转换成<code>ZoneDateTime</code>，然后才能获取UTC时间戳。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime</span> <span class="hljs-operator">=</span> LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());<br><span class="hljs-type">Date</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());<br>System.out.println(out);<br></code></pre></td></tr></table></figure><hr><p>我是Gcoder，一个热爱学习的Java跑马选手。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>千回百转仍需坚守初心</title>
    <link href="/2023/03/03/%E5%8D%83%E5%9B%9E%E7%99%BE%E8%BD%AC%E4%BB%8D%E9%9C%80%E5%9D%9A%E5%AE%88%E5%88%9D%E5%BF%83/"/>
    <url>/2023/03/03/%E5%8D%83%E5%9B%9E%E7%99%BE%E8%BD%AC%E4%BB%8D%E9%9C%80%E5%9D%9A%E5%AE%88%E5%88%9D%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<p><img src="/%E5%8D%83%E5%9B%9E%E7%99%BE%E8%BD%AC%E4%BB%8D%E9%9C%80%E5%9D%9A%E5%AE%88%E5%88%9D%E5%BF%83/bird-7299650_960_720.jpg" alt="bird-7299650_960_720"></p><h3 id="一些想说的话"><a href="#一些想说的话" class="headerlink" title="一些想说的话"></a>一些想说的话</h3><p>人的惰性是越放肆越严重，距离上次的博客之旅一晃又过去了仨年。做人确实没有多少个三年可以浪费的，但是已逝年岁，不咎其责。生活本就是一次又一次的试错，一次又一次的探索，如果前进的方向错了，那停下来就是一种进步。</p><p>马上就要步入而立之年了，同时今年又完成了一件人生大事。迎来了自家的小公主，岁月好似春风一般，仿佛吹到了盛夏，又仿佛存在了一刹，从青葱到成熟，从人夫到人父，生命是一场奇妙之旅，但千回百转也仍需坚守初心。</p><p>每次的幡然醒悟，总会有一个生动的理由。上一次是一个深漂程序员在大城市的有感而发，想分享技术；而如今是一名新晋奶爸想在而立之年记录技术，把坚持和耐心教给我的小公主，做一个极佳的榜样。</p><h3 id="一些最近的感悟"><a href="#一些最近的感悟" class="headerlink" title="一些最近的感悟"></a>一些最近的感悟</h3><p>中年危机是真实存在的，在从事了五年多的开发之后，又遇到了形形色色的同行人或者同龄人。有的人因为资历和年限并不相符而被陷入困境；有的人或因固守成规或因锋芒毕露而寸步难行；也有的人资历尚浅但博学多才；更有甚者而立之年已一身荣耀。从前说，落后就要挨打，诚然这句话也适用于当今的IT圈。技术的日新月异，如同大浪淘沙般不断冲击，能够屹立不倒的人凤毛麟角，而这批人无一不是拥有不断保持学习，不断深入学习的良好品质。</p><p>初心是选择每一条道路的果决与勇敢，还有义无反顾。每条路都会有荆棘和诱惑，不忘初心者善，坚守初心者大善。兜兜转转，我们会在人生的道路上反复徘徊，有时候是不坚定，有时候是不断论证。终其一生，我们会不断完整自己的人生观和价值观。愿有一天，我们皆能得偿所愿。</p><h3 id="一些写在最后的祝福"><a href="#一些写在最后的祝福" class="headerlink" title="一些写在最后的祝福"></a>一些写在最后的祝福</h3><p>最后，兔年是个健康的开端，也是博客重新开始的时候，谨以此文祝福各位平安喜乐！</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
